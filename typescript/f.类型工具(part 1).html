<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/image/favicon.ico"><title></title><meta name="description" content="">
    <link rel="modulepreload" href="/vp-blob.io/assets/app.28445bf9.js"><link rel="modulepreload" href="/vp-blob.io/assets/f.类型工具(part 1).html.398b4e97.js"><link rel="modulepreload" href="/vp-blob.io/assets/f.类型工具(part 1).html.af7e2c7e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.8f018029.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.98776873.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.ec84774a.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.84c58d00.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fb44c11d.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.04557333.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.e4e771ef.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.64a103a2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3013be87.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.f33a1b79.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.f0357039.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.d4018bdd.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.fc637112.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.657af7d7.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.885a698a.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.f1da3f4b.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.71e96b0a.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.a8066bef.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.47b96db6.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a39bfc1a.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.2295a28e.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.3fb1f527.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.d26307e6.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.d7704ccc.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.a198ccc8.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.d5d366e2.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.9962dce2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fe25b76a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.a8456586.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.d6877f1b.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.16fd9c5f.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8ad5ee0.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.e57931a0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.224c5d9e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9483b910.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.21885604.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.afebf168.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.fbc2f79f.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.f5f2a306.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.a8e3ed93.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.4761e1bb.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.645f59cf.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.71743a0c.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.06f977a3.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.ffbf235f.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.03ab869d.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.24317708.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.21818278.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.a0e1348b.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.299f370c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.88fb9194.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.623e016f.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.f71f240c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.70643a0d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.fcb179b9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.a4126bf7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.b9b1e0ca.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.851b045e.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.60e43a8c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.761e4995.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.4c0328e0.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.5f3cb86a.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.8ff82f5e.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.7f1b0f8b.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.b86014e5.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.dba571f1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.c009c8d1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.06394c55.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.cd077274.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.4933004a.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.93146c89.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.0356a730.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9f9140e5.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.98256e4c.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.b052bd8a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3e37b7e7.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.6ff36268.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.b6b2b9e2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c874a8b5.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c3e042f2.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.7a317f56.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.2a865dab.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.311f0358.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.cf697cfd.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.6fb392b7.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.037aad7d.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.1bd949ed.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.52ca17dd.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.f34fa417.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.e44fb0eb.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a09badfd.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.62415c6a.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.037e5a5d.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.013365b5.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.3b025d3c.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.e3e976e6.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.297e089b.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.861f9241.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.f748203e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.18ee491b.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.fcd2c4fb.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.9061575a.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8454023.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.0e8811b9.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c4c65b97.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.547bbfb0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3a04f0a9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.5e39c00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.8d1df225.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.0300e3da.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.4367c6e7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.52adde68.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.1119a5b8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.8c2848ad.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.343d643e.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.cc2b7662.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.8ecb2353.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.1063515b.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.8722a081.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.44ede00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.0bffe771.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.b1a0b6cc.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.83703e49.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.3139a078.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.c6c4dc0a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.036cd62d.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.cfc6577d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.f78bbe87.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.be63d1c8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.93776a99.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.b6fed70c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.bbc94483.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.a38026e9.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.92ecacce.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.644e2aab.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.fe27efa4.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.bd744455.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.b7f872e5.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.53627ba1.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.17ca2b9d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.0ceab273.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.a799acdf.js"><link rel="prefetch" href="/vp-blob.io/assets/404.008f7f9a.js"><link rel="prefetch" href="/vp-blob.io/assets/Layout.f041014c.js"><link rel="prefetch" href="/vp-blob.io/assets/Document.7ddbfa27.js"><link rel="prefetch" href="/vp-blob.io/assets/DocumentIntroduction.642e8662.js"><link rel="prefetch" href="/vp-blob.io/assets/FooBar.72140e24.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNav.c0863aa2.js"><link rel="prefetch" href="/vp-blob.io/assets/TypeScriptPrimitiveAndObject.723d323e.js"><link rel="prefetch" href="/vp-blob.io/assets/aMark.e9a27668.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNote.c64d23bd.js"><link rel="prefetch" href="/vp-blob.io/assets/MyHome.27c67e38.js">
    <link rel="stylesheet" href="/vp-blob.io/assets/style.f819ef42.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vp-blob.io/" class=""><img class="logo" src="/vp-blob.io/image/favicon.ico" alt><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/f.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%201).html#类型别名" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型别名"><!--[--><!--]--> 类型别名 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/f.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%201).html#联合类型与交叉类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="联合类型与交叉类型"><!--[--><!--]--> 联合类型与交叉类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/f.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%201).html#类型索引" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型索引"><!--[--><!--]--> 类型索引 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/f.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%201).html#索引签名类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="索引签名类型"><!--[--><!--]--> 索引签名类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/f.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%201).html#索引类型查询" class="router-link-active router-link-exact-active sidebar-item" aria-label="索引类型查询"><!--[--><!--]--> 索引类型查询 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/f.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%201).html#索引类型访问" class="router-link-active router-link-exact-active sidebar-item" aria-label="索引类型访问"><!--[--><!--]--> 索引类型访问 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/f.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%201).html#映射类型-类型编程第一步" class="router-link-active router-link-exact-active sidebar-item" aria-label="映射类型： 类型编程第一步"><!--[--><!--]--> 映射类型： 类型编程第一步 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><p>类型工具就是可以对类型进行处理的工具。</p><p>按照使用方式划分， 类型工具可以分成三类: <strong>操作符、关键字、专用语法</strong></p><p>按照使用目的划分， 类型工具可以分成两类: <strong>类型创建、类型安全保护</strong></p><h2 id="类型别名" tabindex="-1"><a class="header-anchor" href="#类型别名" aria-hidden="true">#</a> 类型别名</h2><p>类型别名可以说是 typescript 类型编程中最重要的一个功能， 从一个简单的函数类型别名，到让你眼花缭乱的类型体操， 都离不开类型别名</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">A</span></span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>我们通过<code>type</code>关键字声明了一个类型别名 A， 同时它的类型等价于 string 类型。类型别名的主要作用是对一组类型或 特定类型结构进行封装， 以便于在其他地方进行复用。</p><p>比如抽离一组联合类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">StatusCode</span> <span class="token operator">=</span> <span class="token number">200</span> <span class="token operator">|</span> <span class="token number">301</span> <span class="token operator">|</span> <span class="token number">400</span> <span class="token operator">|</span> <span class="token number">500</span> <span class="token operator">|</span> <span class="token number">502</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">PossibleDataTypes</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> status<span class="token operator">:</span> StatusCode <span class="token operator">=</span> <span class="token number">502</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>抽离一个函数类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token operator">:</span> Event<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> clickHandler<span class="token operator">:</span> <span class="token function-variable function">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>声明一个对象类型， 就像接口那样：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ObjectType</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>看起来类型别名真的非常简单， 不过是声明了一个变量让类型声明更加简洁和易于拆分吗？ 如果真的知识把它作为类型别名， 用来进行特定类型的抽离封装， 那的确很简单。 然而， 类型别名还能作为工具类型。</p><p><strong>工具类同样基于类型别名， 只是多了个泛型</strong>.</p><p>在类型别名中， 类型别名可以这么声明自己能够接受泛型。 一旦接受了泛型， 我们就叫他工具类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Factory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>虽然现在类型别名摇身一变成了工具类型， 但他的基本功能仍然是创建类型， 只不过工具类型能够接受泛型参数， 实现<strong>更灵活的类型创建功能</strong>。 从这个角度来看， 工具类型就像一个函数一样， 泛型是入参， 内部逻辑基于 入参进行某些操作， 再返回一个新的类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> foo<span class="token operator">:</span> Factory<span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>当然， 我们一般不会直接使用工具类型做类型标注， 而是再度声明一个新的类型别名：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">FactoryWithBool</span> <span class="token operator">=</span> Factory<span class="token operator">&lt;</span><span class="token builtin">boolean</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> FactoryWithBool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>同时， 泛型参数的名称（上面的 &#39;T&#39;）也不是固定的。 通常我们使用大写的 T / K / U / V / M / O ...这种形式。 如果是为了可读性考虑， 也可以写成大驼峰形式的名称， 比如：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Factory<span class="token operator">&lt;</span>NewType<span class="token operator">&gt;</span></span> <span class="token operator">=</span> NewType <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>声明一个简单、有实际意义的工具类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">MaybeNull<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这个工具类型会接受一个类型， 并返回一个包括 null 的联合类型。 这样一来， 在实际使用时候就可以确保你处理了可能为空值的属性读取与方法调用：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">MaybeNull<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">process</span><span class="token punctuation">(</span>input<span class="token operator">:</span> MaybeNull<span class="token operator">&lt;</span><span class="token punctuation">{</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  input<span class="token operator">?.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>类似的还有 MaybePromise、 MaybeArray。 这也是日常开发中最常用的一类工具类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">MaybeArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">ensureArray</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>input<span class="token operator">:</span> MaybeArray<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token operator">?</span> input <span class="token operator">:</span> <span class="token punctuation">[</span>input<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>另外， 类型别名中可以接受任意个泛型， 以及为泛型指定约束、默认值等， 后面泛型中会讲到。</p><p>总之， 对于工具类来说， 它的主要意义是<strong>基于传入的泛型进行各种类型操作</strong>， 得到一个新的类型， 这个类型操作指代的非常广泛， 甚至说类型编程的大半难度都在这里。</p><h2 id="联合类型与交叉类型" tabindex="-1"><a class="header-anchor" href="#联合类型与交叉类型" aria-hidden="true">#</a> 联合类型与交叉类型</h2><p>前面了解过 联合类型 <code>|</code>, 实际上， 联合类型还有一个和他很像的孪生兄弟： <strong>交叉类型</strong>。 他和联合类型的使用位置一样， 只不过符号是 <code>&amp;</code>, 即按位与运算符。</p><p>实际上， 正如联合类型的符号是 <code>|</code>, 他代表了按位或， 即只需要符合联合类型中的一个类型， 即可以认为实现了这个联合类型， 如 <code>A | B</code>, 只需要实现 A 或 B 即可。</p><p>而代表按位与的 <code>&amp;</code> 则不同， 你需要符合这里的所有类型， 才可以说实现了这个交叉类型， 即 <code>A &amp; B</code>, <strong>需要同时满足 A 与 B 两个类型</strong> 才行：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Name</span> Struct <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">AgeStruct</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">ProfileStruct</span> <span class="token operator">=</span> NameStruct <span class="token operator">&amp;</span> AgeStruct<span class="token punctuation">;</span>

<span class="token keyword">const</span> profile<span class="token operator">:</span> ProfileStruct <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">25</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>很明显这里的 profile 对象需要同时符合这两个对象的结构。 从另一个角度来看， ProfileStruct 其实就是一个新的， 同时包含了 NameStruct 和 AgeStruct 两个接口所有属性的类型。 这里是对于对象的合并， 那对原始类型呢？</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">StrAndNum</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">&amp;</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// never</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>可以看出， 他直接变成了 never， 想想前面给出的定义， 新的类型会同时符合交叉类型的所有成员， 存在既是 string 又是 number 的类型吗？ 当然不存在。 实际上， 这也是 never 这一 BottomType 的实际意义之一， 描述<strong>根本不存在的类型</strong>。</p><p>对于对象类型的交叉类型， 其内部的同名属性类型同样会按照交叉类型进行合并：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Struct1</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  primitiveProp<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  objectProp<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Struct2</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  primitiveProp<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  objectProp<span class="token operator">:</span> <span class="token punctuation">{</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Composed</span> <span class="token operator">=</span> Struct1 <span class="token operator">&amp;</span> Struct2<span class="token punctuation">;</span>

<span class="token comment">// never (string &amp; number)</span>
<span class="token keyword">type</span> <span class="token class-name">PrimitiveProp</span> <span class="token operator">=</span> Composed<span class="token punctuation">[</span><span class="token string">&#39;primitiveProp&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// { name: string; age: number; }</span>
<span class="token keyword">type</span> <span class="token class-name">ObjectProp</span> <span class="token operator">=</span> Composed<span class="token punctuation">[</span><span class="token string">&#39;objectProp&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>如果是两个联合类型组成的交叉类型呢？ 其实还是一样的思路， 既然只需要实现一个联合类型成员 就能认为是实现了这个联合类型， 那么各实现两边联合类型中的一个就行了， 也就是两边联合类型的交集：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 1 | 2</span>
<span class="token keyword">type</span> <span class="token class-name">UnionIntersection1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name">UnionIntersection2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">symbol</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>总结一下联合类型和交叉类型的区别就是，联合类型只需要符合成员之一即可（<code>||</code>）, 而交叉类型需要严格符合每一位成员（<code>&amp;&amp;</code>）.</p><h2 id="类型索引" tabindex="-1"><a class="header-anchor" href="#类型索引" aria-hidden="true">#</a> 类型索引</h2><p>索引类型指的不是某一个特定的类型工具， 他其实包含三个部分：<strong>索引类型签名、索引类型查询、索引类型访问</strong>. 实际上这三者都是独立的类型工具。 唯一的共同点上， <strong>它们都过索引的形式来进行类型操作</strong>， 但索引签名类型是<strong>声明</strong>， 后两者是<strong>读取</strong>。</p><h3 id="索引签名类型" tabindex="-1"><a class="header-anchor" href="#索引签名类型" aria-hidden="true">#</a> 索引签名类型</h3><p>索引签名类型主要是指， 在类型别名或接口中， 通过以下语法来<strong>快速声明一个键值类型一致的类型结构</strong>：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">AllStringTypes</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">AllStringTypes</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这时， 即使你还没声明具体的属性， 对于这些类型结构的访问属性也将全部被视为 string 类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">PropType1</span> <span class="token operator">=</span> AllStringTypes<span class="token punctuation">[</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name">PropType2</span> <span class="token operator">=</span> AllStringTypes<span class="token punctuation">[</span><span class="token string">&#39;233&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这个例子中我们声明的键的类型为 string（ <div class="container" data-v-28f0c476><!--[-->[key: string]<!--]--></div> ), 这也意味着在实现这个类型结构的变量中<strong>只能声明字符串类型的键</strong>。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> foo<span class="token operator">:</span> AllStringTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string-property property">&#39;cqc&#39;</span><span class="token operator">:</span> <span class="token string">&#39;233&#39;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但由于 javascript 中， 对于 <div class="container" data-v-28f0c476><!--[-->obj[prop]<!--]--></div> 形式的访问会将<strong>数字所以访问转换为字符串索引访问</strong>， 也就是说， <div class="container" data-v-28f0c476><!--[-->obj[233]<!--]--></div> 和 <div class="container" data-v-28f0c476><!--[-->obj[&#39;233&#39;]<!--]--></div> 的效果是一致的。 因此，在字符串索引签名类型 中我们仍然可以声明数字类型的键。 类似的 symbol 类型也是如此：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> foo<span class="token operator">:</span> AllStringTypes <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string-property property">&#39;cqc&#39;</span><span class="token operator">:</span> <span class="token string">&#39;233&#39;</span><span class="token punctuation">,</span>
  <span class="token number">233</span><span class="token operator">:</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">&#39;symbol&#39;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>索引签名类型也可以和具体的键值对类型声明并存， 但这时这些具体的键值类型也需要符合索引签名类型的声明:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">AllStringTypes</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 键和值需要符合索引类型</span>

   <span class="token comment">// error:  type &#39;boolean&#39; is not assignable to &#39;string&#39; index type &#39;string | number&#39;</span>
  isBool<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>索引签名类型最常见的场景是在重构 javascript 代码时候， 为内部属性较多的对象声明一个 any 的索引签名类型， 以此来暂时支持<strong>对类型未明确属性的访问</strong>， 并在后续慢慢补全。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">AnyType</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> AnyType<span class="token punctuation">[</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;any value&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="索引类型查询" tabindex="-1"><a class="header-anchor" href="#索引类型查询" aria-hidden="true">#</a> 索引类型查询</h3><p>使用 <div class="container" data-v-28f0c476><!--[-->keyof<!--]--></div> 操作符进行查询。 严谨地说， 他可以将对象中的所有键转换为对应字面量类型， 然后在组合成联合类型。</p><p>注意， <strong>这里并不会将数字类型的键名转换为字符串类型字面量， 而是仍然保持为数字类型字面量</strong> 。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token number">233</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token string-property property">&#39;333&#39;</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">FooKeys</span> <span class="token operator">=</span> <span class="token keyword">keyof</span> Foo<span class="token punctuation">;</span> <span class="token comment">// &#39;name&#39; | 233 | &#39;333&#39;  (数字字面量类型仍然保持为数字类型字面量)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>除了应用在已知的对象类型结构上以外， 你还可以直接 <div class="container" data-v-28f0c476><!--[-->keyof any<!--]--></div> 来生产一个联合类型， 它会由所有可用作对象键值的类型组成： <div class="container" data-v-28f0c476><!--[-->string | number | symbol<!--]--></div>。也就是说， 他是由无数字面量类型组成的， 由此我们可以知道， <strong>keyof 的产物必定是一个联合类型</strong>。</p><h3 id="索引类型访问" tabindex="-1"><a class="header-anchor" href="#索引类型访问" aria-hidden="true">#</a> 索引类型访问</h3><p>在 javascript 中 我们可以通过 <code>obj[expression]</code> 的方式来动态访问一个对象属性（即计算属性）， expression 表达式会先被执行， 然后实现用回值来访问属性。 而 typescript 中我们也可以通过类型的方式， 只不过这里的 expression 要更换成类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">NumberRecord</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PropType</span> <span class="token operator">=</span> NumberRecord<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里， 我们使用 string 类型来访问 NumberRecord. 由于其内部声明了数字类型的索引签名， 这里访问到的结果即是 number 类型。 注意， 其访问方式与返回值均是类型。</p><p>更直观的例子是通过字面量类型来进行索引类型访问：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PropName</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name">PropAge</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token string">&#39;age&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>看起来这里就是普通的值访问， 但实际上这里的 <code>name</code> 和 <code>age</code> 都是<strong>字符串字面量类型， 而不是一个 javascript 字符串值</strong>。 索引类型查询的本质其实就是， <strong>通过键的字面量类型(<code>&#39;name&#39;</code>)访问这个键对应的键值类型(<code>string</code>)</strong>.</p><p>看到这里你肯定会想到， 上面的 keyof 操作符能一次性获取这个对象所有的键的字面量类型， 是否能用在这里？ 当然， 这里可是 typescript !</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  PropA<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  PropB<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  PropC<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PropTypeUnion</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token keyword">keyof</span> Foo<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// number | string | boolean</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>使用字面量联合类型进行索引类型访问时， 其结果就是将联合类型每个分支对应的类型进行访问后的结果， 重新组装成联合类型。 <strong>索引类型查询、索引类型访问通常会和映射类型一起搭配使用</strong>， 前两者负责访问键， 而映射类型在其基础上访问键值类型（映射类型下面讲到）。</p><p>注意， 在未声明索引签名类型的情况下， 我们不能使用 <div class="container" data-v-28f0c476><!--[-->Foo[string]<!--]--></div> 这种原始类型的访问方式， 而只能通过键名的字面量类型来进行访问。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  PropA<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">PropAType</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token string">&#39;PropA&#39;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// Error: 类型 Foo 没有匹配类型 &#39;string&#39; 的索引签名</span>
<span class="token keyword">type</span> <span class="token class-name">PropAType</span> <span class="token operator">=</span> Foo<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>索引类型的最佳拍档之一就是映射类型， 同时映射类型也是类型编程中常用的一个手段。</p><h3 id="映射类型-类型编程第一步" tabindex="-1"><a class="header-anchor" href="#映射类型-类型编程第一步" aria-hidden="true">#</a> 映射类型： 类型编程第一步</h3><p>不同于索引类型包含好几个部分， 映射类型指的就是一个确切的类型工具。 看到映射这个词你应该 能联想到 javascript 中数组的 map 方法， 实际上也是如此， 映射类型的主要作用即是<strong>基于键名映射到键值类型</strong>。 概念不好理解， 直接上例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Stringify<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span>key <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这个工具类型会接受一个对象类型（假设我们只会这么用）， 使用 keyof 获得这个对象类型的键名组成字面量联合类型， 然后通过映射类型（即这里的 in 关键字） 将这个联合类型的每一个成员映射出来， 并将其键值类型 设置为 string。</p><p>具体使用的表现上这样的：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  prop1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  prop2<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  prop3<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  <span class="token function-variable function">prop4</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">StringifyFoo</span> <span class="token operator">=</span> Stringify<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// 等价于</span>
<span class="token keyword">interface</span> <span class="token class-name">StringifyFoo</span> <span class="token punctuation">{</span>
  prop1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  prop2<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  prop3<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  prop4<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>我们可以使用 伪代码的形式进行说明：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> StringFieldFoo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> k <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  StringFieldFoo<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>看起来好像很奇怪， 我们应该很少会需要把一个接口的所有属性类型映射到 string？ 这有什么意义吗？</p><p>既然拿到了键， 那键值类型其实也能拿到：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Clone<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">[</span><span class="token constant">K</span> <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的 <code>T[K]</code> 其实就是上面说到的索引类型访问， 我们使用键的字面量类型访问到了键值的类型， 这里相当于克隆了一个接口。 这里需要注意的是， 只有 <code>K in</code> 属于映射类型的语法， <code>keyof T</code> 属于 keyof 操作符， <code>[K in keyof T]</code> 的 <code>[]</code> 属于索引类型签名， <code>T[K]</code> 属于索引类型访问。</p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/cqc-hub/vp-blob.io/tree/master/docs/typescript/f.类型工具(part 1).md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vp-blob.io/typescript/e.any | unknown | never.html" class="" aria-label="e.any | unknown | never"><!--[--><!--]--> e.any | unknown | never <!--[--><!--]--></a></span><span class="next"><a href="/vp-blob.io/typescript/g.类型工具(part 2).html" class="" aria-label="g.类型工具(part 2)"><!--[--><!--]--> g.类型工具(part 2) <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vp-blob.io/assets/app.28445bf9.js" defer></script>
  </body>
</html>

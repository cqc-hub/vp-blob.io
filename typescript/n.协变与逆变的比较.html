<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/image/favicon.ico"><title></title><meta name="description" content="">
    <link rel="modulepreload" href="/vp-blob.io/assets/app.28445bf9.js"><link rel="modulepreload" href="/vp-blob.io/assets/n.协变与逆变的比较.html.037e5a5d.js"><link rel="modulepreload" href="/vp-blob.io/assets/n.协变与逆变的比较.html.3fb1f527.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.8f018029.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.98776873.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.ec84774a.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.84c58d00.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fb44c11d.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.04557333.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.e4e771ef.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.64a103a2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3013be87.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.f33a1b79.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.f0357039.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.d4018bdd.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.fc637112.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.657af7d7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.af7e2c7e.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.885a698a.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.f1da3f4b.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.71e96b0a.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.a8066bef.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.47b96db6.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a39bfc1a.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.2295a28e.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.d26307e6.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.d7704ccc.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.a198ccc8.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.d5d366e2.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.9962dce2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fe25b76a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.a8456586.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.d6877f1b.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.16fd9c5f.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8ad5ee0.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.e57931a0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.224c5d9e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9483b910.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.21885604.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.afebf168.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.fbc2f79f.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.f5f2a306.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.a8e3ed93.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.4761e1bb.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.645f59cf.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.71743a0c.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.06f977a3.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.ffbf235f.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.03ab869d.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.24317708.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.21818278.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.a0e1348b.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.299f370c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.88fb9194.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.623e016f.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.f71f240c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.70643a0d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.fcb179b9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.a4126bf7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.b9b1e0ca.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.851b045e.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.60e43a8c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.761e4995.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.4c0328e0.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.5f3cb86a.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.8ff82f5e.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.7f1b0f8b.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.b86014e5.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.dba571f1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.c009c8d1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.06394c55.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.cd077274.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.4933004a.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.93146c89.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.0356a730.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9f9140e5.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.98256e4c.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.b052bd8a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3e37b7e7.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.6ff36268.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.b6b2b9e2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c874a8b5.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c3e042f2.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.7a317f56.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.2a865dab.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.311f0358.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.cf697cfd.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.6fb392b7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.398b4e97.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.037aad7d.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.1bd949ed.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.52ca17dd.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.f34fa417.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.e44fb0eb.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a09badfd.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.62415c6a.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.013365b5.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.3b025d3c.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.e3e976e6.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.297e089b.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.861f9241.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.f748203e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.18ee491b.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.fcd2c4fb.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.9061575a.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8454023.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.0e8811b9.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c4c65b97.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.547bbfb0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3a04f0a9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.5e39c00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.8d1df225.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.0300e3da.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.4367c6e7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.52adde68.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.1119a5b8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.8c2848ad.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.343d643e.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.cc2b7662.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.8ecb2353.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.1063515b.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.8722a081.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.44ede00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.0bffe771.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.b1a0b6cc.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.83703e49.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.3139a078.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.c6c4dc0a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.036cd62d.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.cfc6577d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.f78bbe87.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.be63d1c8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.93776a99.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.b6fed70c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.bbc94483.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.a38026e9.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.92ecacce.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.644e2aab.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.fe27efa4.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.bd744455.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.b7f872e5.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.53627ba1.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.17ca2b9d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.0ceab273.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.a799acdf.js"><link rel="prefetch" href="/vp-blob.io/assets/404.008f7f9a.js"><link rel="prefetch" href="/vp-blob.io/assets/Layout.f041014c.js"><link rel="prefetch" href="/vp-blob.io/assets/Document.7ddbfa27.js"><link rel="prefetch" href="/vp-blob.io/assets/DocumentIntroduction.642e8662.js"><link rel="prefetch" href="/vp-blob.io/assets/FooBar.72140e24.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNav.c0863aa2.js"><link rel="prefetch" href="/vp-blob.io/assets/TypeScriptPrimitiveAndObject.723d323e.js"><link rel="prefetch" href="/vp-blob.io/assets/aMark.e9a27668.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNote.c64d23bd.js"><link rel="prefetch" href="/vp-blob.io/assets/MyHome.27c67e38.js">
    <link rel="stylesheet" href="/vp-blob.io/assets/style.f819ef42.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vp-blob.io/" class=""><img class="logo" src="/vp-blob.io/image/favicon.ico" alt><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#总结" class="router-link-active router-link-exact-active sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#函数有类型层级嘛-如果有-下面类型层级又是什么样子的" class="router-link-active router-link-exact-active sidebar-item" aria-label="函数有类型层级嘛？ 如果有， 下面类型层级又是什么样子的"><!--[--><!--]--> 函数有类型层级嘛？ 如果有， 下面类型层级又是什么样子的 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#比较函数类型签名" class="router-link-active router-link-exact-active sidebar-item" aria-label="比较函数类型签名"><!--[--><!--]--> 比较函数类型签名 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#协变与逆变" class="router-link-active router-link-exact-active sidebar-item" aria-label="协变与逆变"><!--[--><!--]--> 协变与逆变 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#tsconfig-中的-strictfunctiontypes" class="router-link-active router-link-exact-active sidebar-item" aria-label="TsConfig 中的 StrictFunctionTypes"><!--[--><!--]--> TsConfig 中的 StrictFunctionTypes <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#扩展" class="router-link-active router-link-exact-active sidebar-item" aria-label="扩展"><!--[--><!--]--> 扩展 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#联合类型与兄弟类型下的比较" class="router-link-active router-link-exact-active sidebar-item" aria-label="联合类型与兄弟类型下的比较"><!--[--><!--]--> 联合类型与兄弟类型下的比较 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/n.%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98%E7%9A%84%E6%AF%94%E8%BE%83.html#非函数签名包装类型的变换" class="router-link-active router-link-exact-active sidebar-item" aria-label="非函数签名包装类型的变换"><!--[--><!--]--> 非函数签名包装类型的变换 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本章节没看懂， 只需要硬记 两点(在入参、出参 为继承关系且在开启严格函数类型检查的前提下的 函数类型) 只针对类型声明是通过 property 时候生效, (method 声明不生效（也就是说在 method 声明中函数是 双变的）)</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// method 声明</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token punctuation">{</span>
 <span class="token function">func</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// property 声明</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token punctuation">{</span>
 <span class="token function-variable function">func</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li>对于入参 <div class="container" data-v-28f0c476><!--[-->((parent) =&gt; void) extends ((child) =&gt; void) <!--]--></div> 成立</li><li>对于出参 <div class="container" data-v-28f0c476><!--[-->(() =&gt; child) extends (() =&gt; parent)<!--]--></div> 成立</li></ul><p>可以通过 TypeScript ESLint 的规则以及 strictFunctionTypes 配置，来为 interface 内的函数声明启用严格的检查模式。</p><p>以下是正文</p><h2 id="函数有类型层级嘛-如果有-下面类型层级又是什么样子的" tabindex="-1"><a class="header-anchor" href="#函数有类型层级嘛-如果有-下面类型层级又是什么样子的" aria-hidden="true">#</a> 函数有类型层级嘛？ 如果有， 下面类型层级又是什么样子的</h2><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">FooFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">BarFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">BarzFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="比较函数类型签名" tabindex="-1"><a class="header-anchor" href="#比较函数类型签名" aria-hidden="true">#</a> 比较函数类型签名</h2><p>首先要明确的是。 我们不会使用函数类型和其他类型（比如对象）比较， 因为这并没有什么意义， 本文中只会讲两个函数类型之间的比较。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
 <span class="token function">asPat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
 <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Corgi</span> <span class="token keyword">extends</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>
 <span class="token function">cute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>对于一个接受 Dog 类型并返回 Dog 类型的函数， 我们可以这样表示</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">DogFactory</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Dog<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在本文中， 我们将其进一步简化为： <code>Dog -&gt; Dog</code> 的表达形式。</p><p>对于函数类型的比较， 实际上我们要比较的即是参数类型与返回值类型（也只能是这俩位置）， 对于 Animal、Dog、Corgi 这三个类， 如果将它们分别可重复地放置在参数类型与返回值类型处， 相当于排列组合， 就可以得到以下这些函数签名类型：</p><blockquote><p>这里的结果不包括 <code>Dog -&gt; Dog</code>, 因为我们要用它作为基础来被比较</p></blockquote><ul><li><code>Animal -&gt; Animal</code></li><li><code>Animal -&gt; Dog</code></li><li><code>Animal -&gt; Corgi</code></li><li><code>Dog -&gt; Dog</code></li><li><code>Dog -&gt; Animal</code></li><li><code>Dog -&gt; Corgi</code></li><li><code>Corgi -&gt; Corgi</code></li><li><code>Corgi -&gt; Dog</code></li><li><code>Corgi -&gt; Animal</code></li></ul><p>直接比较完整的函数类型并不符合我们的思维直觉， 因此我们需要引入一个辅助函数： 它接受一个 <code>Dog -&gt; Dog</code> 类型的参数：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">transformDogAndBark</span><span class="token punctuation">(</span>dogFactory<span class="token operator">:</span> DogFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> dog <span class="token operator">=</span> <span class="token function">dogFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>对于函数参数， 实际上类似于我们在类型系统层级时候讲到的， <strong>如果一个值能够被赋值给某个类型的变量， 那么可以认为这个值的类型为此变量的子类型</strong></p><p>如一个简单接受 Dog 参数类型的函数：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">makeDogBark</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>它在调用时候只可能接受 Dog 类型 或 Dog 类型的子类型， 而不能接受 Dog 类型的父类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token function">makeDogBark</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Corgi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  可以</span>
<span class="token function">makeDogBark</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>相对严谨的说， 这是因为 派生类（即子类） 会保留基类的属性和方法， 因此说其与基类兼容， 但基类不能未卜先知的拥有子类的方法。 相对形象地来说， 因为我们要让这只狗汪汪两声， 柯基、德牧 都会， 但如果你传个牛进来， 就很难办了。</p><blockquote><p>里氏替换原则， 子类可以拓展父类的内容， 但不能改变父类原有的功能， 子类型 必须能够替换掉它们的基类</p></blockquote><p>回到这个函数， 我们只会传入一只正常的狗狗， 但他不一定是什么品种。 其次， 你返回的也必须是一只狗狗， 我并不在意它是什么品种。</p><p>对这两条约束依次进行检查：</p><ul><li><p>对于 <code>Animal/Dog/Corgi -&gt; Animal</code> 类型， 无论他的参数类型是什么样的， 他的返回值类型都是不满足条件的。 因为它返回的并不一定是合法的狗狗， 即我们说它不是 <code>Dog -&gt; Dog</code> 的子类</p></li><li><p>对于 <code>Corgi -&gt; Corgi</code> 与 <code>Corgi -&gt; Dog</code>, 其返回值满足了条件， 但是参数类型又不满足了。这两个类型需要接受 Corgi 类型， 可能程序内部需要它腿短的这个特性， 但我们可没说一定会传入柯基， 如果我们传个德牧， 程序可能就崩溃了</p></li><li><p>对于 <code>Dog -&gt; Corgi</code>, <code>Animal -&gt; Corgi</code> 、 <code>Animal -&gt; Dog</code>, 首先它们的参数类型正确的满足了约束，能接受一只狗狗。 其次， 它们返回值类型也一定能 汪汪汪</p></li></ul><p>而实际上， 如果我们去掉了包涵 Dog 类型的例子 会发现只剩下 <code>Animal -&gt; Corgi</code> 了， 也即是说， <code>(Animal -&gt; Corgi) ≼ (Dog -&gt; Dog)</code> 成立（A ≼ B 意为 A 为 B 的子类型）</p><p>观察以上排除方式的结论：</p><ul><li>参数类型<strong>允许</strong>为 Dog 的父类型， <strong>不允许</strong>为 Dog 的子类型。</li><li>返回值的类型<strong>允许为 Dog</strong>的子类型， <strong>不允许</strong>为 Dog的父类</li></ul><p>你是否 get 到了什么？ 这里用来比较的两个函数类型， 其实就是把具有父子关系的类型放置在参数、返回值 的位置上， <strong>最终函数类型的关系直接取决于类型的父子关系</strong>， 取决于也就意味着其中有迹可循， 这个时候， 就可以引入协变与逆变的关系了。</p><h2 id="协变与逆变" tabindex="-1"><a class="header-anchor" href="#协变与逆变" aria-hidden="true">#</a> 协变与逆变</h2><p>上一节我们得到的结论是 考虑 <code>Corgi ≼ Dog ≼ Animal</code>, 当有函数类型 <code>Dog -&gt; Dog</code>, 仅有 <code>Animal -&gt; Corgi ≼ Dog -&gt; Dog</code> 成立（即能被视为此函数的子类型）， 这里的参数类型与返回值实际上可以各自独立出来看：</p><p>考虑 <code>Corgi ≼ Dog</code>, 假设我们对其返回值类型的函数签名类型包装， 则有 <code>(T -&gt; Corgi) ≼ (T -&gt; Dog)</code>, 也就是说， 在我需要狗狗的地方， 柯基都是可以用的。 即不考虑参数类型的情况， 在包装为函数签名的返回值类型后， 其子类型层级关系保持一致。</p><p>考虑 <code>Dog ≼ Animal</code>, 如果参数类型的函数签名类型包装， 则有 <code>Animal -&gt; T ≼ Dog -&gt; T</code>, 也即是说， <strong>在我需要条件满足是动物时， 狗狗都是可用的</strong>。 即不考虑返回值类型的情况， 在为函数签名的参数类型包装后， 其子类型层级发生了逆变。</p><p>实际上， 这就是 typescript 中的 协变 与逆变 在函数签名类型中的表现形式。 这个单词最初来自于几何学领域中：<strong>随着某一个量的变化， 随之变化一致的即称为协变， 而变化相反的即称为逆变</strong></p><p>用 typescript 的思路进行转换， 即如果有 <code>A ≼ B</code>(A 是 B 的子类型)， 协变意味着 <code>Wrapper&lt;A&gt; ≼ Wrapper&lt;B&gt;</code>, 而逆变意味着 <code>Wrapper&lt;B&gt; ≼ Wrapper&lt;A&gt;</code>;</p><p>而在这里的示例中， <strong>变化（Wrapper） 即指从单个类型到函数类型的包装过程</strong>， 我们可以使用工具类型来实现独立的包装类型（独立指对参数类型与返回值类型）:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">AsFuncArgType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">AsFuncReturnType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>再使用这俩个包装类型演示我们上面的例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 成立 (T -&gt; Corgi） ≼ (T -&gt; Dog),   (T -&gt; Corgi) 是 (T -&gt; Dog) 的子类型</span>
<span class="token keyword">type</span> <span class="token class-name">CheckReturnType</span> <span class="token operator">=</span> AsFuncReturnType<span class="token operator">&lt;</span>Corgi<span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name">AsFuncReturnType<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span></span>
 <span class="token operator">?</span> <span class="token number">1</span>
 <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>

  <span class="token comment">// 不成立, 结论： (Dog -&gt; T) ≼ (Animal -&gt; T)</span>
<span class="token keyword">type</span> <span class="token class-name">CheckArgType</span> <span class="token operator">=</span> AsFuncArgType<span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name">AsFuncArgType<span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>进行一个总结， <strong>函数类型的参数类型使用子类型逆变的方式确定是否成立， 而返回值类型使用子类型协变的方式确定</strong></p><h2 id="tsconfig-中的-strictfunctiontypes" tabindex="-1"><a class="header-anchor" href="#tsconfig-中的-strictfunctiontypes" aria-hidden="true">#</a> TsConfig 中的 StrictFunctionTypes</h2><p>功能描述：</p><p>在比较两个函数类型是否兼容时候， 将对函数参数进行更严格的检查， 而实际上， 这里的更严格指的即是 <strong>对函数参数类型启用逆变检查</strong>， 很自然的我们会产生一些疑问：</p><p>如果启用了这个配置才是逆变检查， 那么原来是怎么样子的？ 在实际场景中的逆变检查又是什么样子的？</p><p>还是以上面三个类为例：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">CorgiFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Corgi<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">AnimalFunc</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>我们通过赋值方式来实现对函数类型的比较：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> fun1<span class="token operator">:</span> CorgiFunc <span class="token operator">=</span> fn<span class="token punctuation">;</span>
<span class="token keyword">const</span> fun2<span class="token operator">:</span> AnimalFunc <span class="token operator">=</span> fn<span class="token punctuation">;</span> <span class="token comment">// err</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>还记得嘛？ 如果赋值成立， 说明 fn 的类型是 <code>CorgiFunc</code> / <code>AnimalFunc</code> 的子类型;</p><p>这两个赋值实际上等价于：</p><ul><li><p><code>(Dog -&gt; T) ≼ (Corgi -&gt; T)</code></p></li><li><p><code>(Dog -&gt; T) ≼ (Animal) -&gt; T</code></p></li></ul><p>结合上面所学， 我们很明显能够发现第二种应当是不成立的， 但是在禁用了 <code>strictFunctionTypes</code> 的情况下， typescript 并不会抛出错误。 这是因为， 在默认情况下， 对函数参数的检查采用<strong>双变</strong>， <strong>即逆变和协变都被认为是可以接受的</strong></p><p>在 typescript eslint 中， 有这么一条规则：<a href="https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/method-signature-style.md" target="_blank" rel="noopener noreferrer">method-signature-style<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>, 他的意图是约束在接口中声明方法时， 需要使用 property 而非 method 形式</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// method 声明</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T1</span></span> <span class="token punctuation">{</span>
 <span class="token function">func</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// property 声明</span>
<span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">T2</span></span> <span class="token punctuation">{</span>
 <span class="token function-variable function">func</span><span class="token operator">:</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>进行如此约束的原因， 对于 property 声明， 才能在开启严格函数类型检查的情况下享受到<strong>基于逆变的参数类型检查</strong></p><p>对于 method 声明（以及构造函数声明）， 其无法享受到这一更严格的检查原因则是对于 如 Array 这样的定义， 我们希望他的函数方法就是以协变的方式进行检查， 举个例子， <code>Dog[] ≼ Animal[]</code> 是否成立？</p><ul><li>我们并不能简单比较 Dog 与 Animal ， 而是要将它们视为两个完整的类型比较， 即 <code>Dog[]</code> 的每一个成员（属性、方法）是否都能对应的赋值 给 <code>Animal[]</code></li><li><code>Dog[].push ≼ Animal[].push</code> 是否成立?</li><li>由 push 方法的类型签名进一步推导， <code>Dog -&gt; void ≼ Animal -&gt; void</code> 是否成立?</li><li><code>Dog -&gt; void ≼ Animal -&gt; void</code> 在逆变的情况下意味着 <code>Animal ≼ Dog</code>, 而这很明显是不对的！</li><li>简单来说， <code>Dog -&gt; void ≼ Animal -&gt; void</code> 是否成立本身就为 <code>Dog[] ≼ Animal</code> 提供了一个前提答案</li></ul><p>因此， 如果 typescript 在此时仍然强制使用参数逆变的规则进行检查， 那么 <code>Dog[] ≼ Animal[]</code> 就无法成立， 也就意味着 无法将 Dog 赋值给 Animal， 这不就前后矛盾了嘛？所以在大部分情况下， 我们确实希望方法参数类型的检查是可以双变， 这也是为什么它们的声明中类型结构使用 method 方式来声明：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>items<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h2><h3 id="联合类型与兄弟类型下的比较" tabindex="-1"><a class="header-anchor" href="#联合类型与兄弟类型下的比较" aria-hidden="true">#</a> 联合类型与兄弟类型下的比较</h3><p>上面我们只关注了显示父子类型关系， 实际上在类型层级中还有隐式的父子类型关系（联合类型） 以及兄弟类型（同一基类的两个派生类）。 对于隐式的父子类型其可以仍然沿用显式的父子类型协变与逆变判断， 但对于兄弟类型， 比如 Dog 与 Cat， 需要注意的是它们根本就<strong>不满足逆变与协变的发生条件（父子关系）</strong>， 因此 <code>(Cat -&gt; void) ≼ (Dog -&gt; void)</code> (或者反过来)， 无论在严格检查还是默认检查下均不成立。</p><h3 id="非函数签名包装类型的变换" tabindex="-1"><a class="header-anchor" href="#非函数签名包装类型的变换" aria-hidden="true">#</a> 非函数签名包装类型的变换</h3><p>我们在最开始一直以函数体作为包装类型来作为协变与逆变的转变前提， 后面虽然提到了使用数组的作为包装类型（<code>Dog[]</code>）, 但只是一笔带过，重点还是在函数体方面。 现在， 如果我们就是要考虑类似数组这种包装类型呢？ 比如直接一个简单的笼子 Cage？</p><p>先不考虑 Cage 内部的实现， 只知道它同时只能放一个物种的动物， <code>Cage&lt;Dog&gt;</code> 能被作为 <code>Cage&lt;Animal&gt;</code> 的子类型嘛？ 对于这一类型的比较， 我们可以直接使用实际场景来代入:</p><ul><li><p>假设我需要一笼动物， 但并不会对它们进行除了读以外的操作，那么你给我一笼狗也是可以的， 但你不能给我一笼植物。 也就意味着， 此时 List 是 readonly 的， 而 <code>Cage&lt;Dog&gt; ≼ Cage&lt;Animal&gt;</code> 成立. <strong>即在不可变的 Wrapper 中， 我们允许其遵循协变</strong></p></li><li><p>假设我需要一笼动物， 并且会在其中新增其他物种， 比如说兔子啊王八， 这个时候你给我一笼兔子就不行了， 因为这个笼子只能放狗， 放兔子可能会变异（？）， 也就意味着， 此时 List 是 Writable 的， 而 <code>Cage&lt;Dog&gt; Cage&lt;Rabit&gt; Cage&lt;Turtle&gt;</code> 彼此之间是互斥的， 我们称为 <strong>不变</strong>， 用来放狗的笼子绝不能用来放兔子， 即无法分配</p></li><li><p>如果我们再改下规则， 现在一个笼子可以放任意物种的动物， 狗和兔子可以放一个笼子里， 这个时候任意笼子都可以放任意物种， 放狗的可以放兔子， 放兔子的也可以放狗， 即可以互相分配， 我们称之为 <strong>双变</strong>。</p></li></ul><p>也就是说， 包装类型的表现与我们实际需要的效果是紧密联系的</p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/cqc-hub/vp-blob.io/tree/master/docs/typescript/n.协变与逆变的比较.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vp-blob.io/typescript/n.协变与逆变的比较.html" class="" aria-label="n.协变与逆变的比较"><!--[--><!--]--> n.协变与逆变的比较 <!--[--><!--]--></a></span><span class="next"><a href="/vp-blob.io/typescript/o.进阶.html" class="" aria-label="o.进阶"><!--[--><!--]--> o.进阶 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vp-blob.io/assets/app.28445bf9.js" defer></script>
  </body>
</html>

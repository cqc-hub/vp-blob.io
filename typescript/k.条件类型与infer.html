<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/image/favicon.ico"><title></title><meta name="description" content="">
    <link rel="modulepreload" href="/vp-blob.io/assets/app.28445bf9.js"><link rel="modulepreload" href="/vp-blob.io/assets/k.条件类型与infer.html.e44fb0eb.js"><link rel="modulepreload" href="/vp-blob.io/assets/k.条件类型与infer.html.47b96db6.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.8f018029.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.98776873.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.ec84774a.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.84c58d00.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fb44c11d.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.04557333.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.e4e771ef.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.64a103a2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3013be87.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.f33a1b79.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.f0357039.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.d4018bdd.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.fc637112.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.657af7d7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.af7e2c7e.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.885a698a.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.f1da3f4b.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.71e96b0a.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.a8066bef.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a39bfc1a.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.2295a28e.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.3fb1f527.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.d26307e6.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.d7704ccc.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.a198ccc8.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.d5d366e2.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.9962dce2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fe25b76a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.a8456586.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.d6877f1b.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.16fd9c5f.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8ad5ee0.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.e57931a0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.224c5d9e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9483b910.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.21885604.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.afebf168.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.fbc2f79f.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.f5f2a306.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.a8e3ed93.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.4761e1bb.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.645f59cf.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.71743a0c.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.06f977a3.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.ffbf235f.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.03ab869d.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.24317708.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.21818278.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.a0e1348b.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.299f370c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.88fb9194.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.623e016f.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.f71f240c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.70643a0d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.fcb179b9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.a4126bf7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.b9b1e0ca.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.851b045e.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.60e43a8c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.761e4995.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.4c0328e0.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.5f3cb86a.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.8ff82f5e.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.7f1b0f8b.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.b86014e5.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.dba571f1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.c009c8d1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.06394c55.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.cd077274.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.4933004a.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.93146c89.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.0356a730.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9f9140e5.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.98256e4c.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.b052bd8a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3e37b7e7.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.6ff36268.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.b6b2b9e2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c874a8b5.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c3e042f2.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.7a317f56.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.2a865dab.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.311f0358.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.cf697cfd.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.6fb392b7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.398b4e97.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.037aad7d.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.1bd949ed.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.52ca17dd.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.f34fa417.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a09badfd.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.62415c6a.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.037e5a5d.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.013365b5.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.3b025d3c.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.e3e976e6.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.297e089b.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.861f9241.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.f748203e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.18ee491b.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.fcd2c4fb.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.9061575a.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8454023.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.0e8811b9.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c4c65b97.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.547bbfb0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3a04f0a9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.5e39c00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.8d1df225.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.0300e3da.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.4367c6e7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.52adde68.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.1119a5b8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.8c2848ad.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.343d643e.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.cc2b7662.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.8ecb2353.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.1063515b.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.8722a081.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.44ede00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.0bffe771.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.b1a0b6cc.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.83703e49.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.3139a078.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.c6c4dc0a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.036cd62d.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.cfc6577d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.f78bbe87.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.be63d1c8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.93776a99.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.b6fed70c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.bbc94483.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.a38026e9.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.92ecacce.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.644e2aab.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.fe27efa4.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.bd744455.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.b7f872e5.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.53627ba1.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.17ca2b9d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.0ceab273.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.a799acdf.js"><link rel="prefetch" href="/vp-blob.io/assets/404.008f7f9a.js"><link rel="prefetch" href="/vp-blob.io/assets/Layout.f041014c.js"><link rel="prefetch" href="/vp-blob.io/assets/Document.7ddbfa27.js"><link rel="prefetch" href="/vp-blob.io/assets/DocumentIntroduction.642e8662.js"><link rel="prefetch" href="/vp-blob.io/assets/FooBar.72140e24.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNav.c0863aa2.js"><link rel="prefetch" href="/vp-blob.io/assets/TypeScriptPrimitiveAndObject.723d323e.js"><link rel="prefetch" href="/vp-blob.io/assets/aMark.e9a27668.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNote.c64d23bd.js"><link rel="prefetch" href="/vp-blob.io/assets/MyHome.27c67e38.js">
    <link rel="stylesheet" href="/vp-blob.io/assets/style.f819ef42.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vp-blob.io/" class=""><img class="logo" src="/vp-blob.io/image/favicon.ico" alt><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#条件类型基础" class="router-link-active router-link-exact-active sidebar-item" aria-label="条件类型基础"><!--[--><!--]--> 条件类型基础 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#infer-关键字" class="router-link-active router-link-exact-active sidebar-item" aria-label="infer 关键字"><!--[--><!--]--> infer 关键字 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="函数"><!--[--><!--]--> 函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#数组" class="router-link-active router-link-exact-active sidebar-item" aria-label="数组"><!--[--><!--]--> 数组 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#接口" class="router-link-active router-link-exact-active sidebar-item" aria-label="接口"><!--[--><!--]--> 接口 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#promise" class="router-link-active router-link-exact-active sidebar-item" aria-label="Promise"><!--[--><!--]--> Promise <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#分布式条件类型" class="router-link-active router-link-exact-active sidebar-item" aria-label="分布式条件类型"><!--[--><!--]--> 分布式条件类型 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#扩展" class="router-link-active router-link-exact-active sidebar-item" aria-label="扩展"><!--[--><!--]--> 扩展 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#isany" class="router-link-active router-link-exact-active sidebar-item" aria-label="IsAny"><!--[--><!--]--> IsAny <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/k.%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8Einfer.html#isunknown" class="router-link-active router-link-exact-active sidebar-item" aria-label="IsUnknown"><!--[--><!--]--> IsUnknown <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><h2 id="条件类型基础" tabindex="-1"><a class="header-anchor" href="#条件类型基础" aria-hidden="true">#</a> 条件类型基础</h2><p>条件类型的语法类似于平常使用的三元表达式(伪代码)：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>ValueA <span class="token operator">===</span> ValueB <span class="token operator">?</span> Result1 <span class="token operator">:</span> Result2<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>但需要注意的是， 条件类型中使用 extends 判断类型的兼容性， 而非判断类型的全等性。 这是因为在类型层面中， 对于能够进行赋值操作的两个变量， 我们<strong>并不需要他们的类型完全相等， 只需要具备兼容性</strong>， 对于两个完全相同的类型， 其 extends 自然也是成立的</p><p>条件类型绝大部分场景下回合泛型一起使用， 泛型参数的实际类型会在实际调用时才被填充（类型别名中显示传入， 或者函数中隐式提取）， 而条件类型在这一基础上， 可以基于填充后的泛型参数做进一步的类型操作：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">LiteralType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token string">&#39;string&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;other&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token string">&#39;cqc&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;string&#39;</span>
<span class="token keyword">type</span> <span class="token class-name">Res2</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token number">233</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;other&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>同三元表达式一样， 条件类型中也常见多层嵌套：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">LiteralType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>
 <span class="token operator">?</span> <span class="token string">&#39;string&#39;</span>
 <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>
 <span class="token operator">?</span> <span class="token string">&#39;number&#39;</span>
 <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span>
 <span class="token operator">?</span> <span class="token string">&#39;boolean&#39;</span>
 <span class="token operator">:</span> <span class="token string">&#39;other&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Res1</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token string">&#39;cqc&#39;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;string&#39;</span>
<span class="token keyword">type</span> <span class="token class-name">Res2</span> <span class="token operator">=</span> LiteralType<span class="token operator">&lt;</span><span class="token number">233</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;number&#39;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>而在函数中， 条件类型与泛型搭配同样非常常见， 考考你， 以下这个函数， 我们应该如何标注它的返回值类型</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">universalAdd</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> bigint<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>当我们调用这个函数时候， 由于两个参数都引用了泛型参数 T， 因此泛型会被填充为一个联合类型:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token number">233</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T 填充为 233 | 23</span>
<span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;233&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// T 填充为 &#39;cqc&#39; | &#39;233&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>那么此时的返回值类型就需要从这个字面量联合类型中推导回其原本的基础类型。 在类型层级一节中， 我们知道 <strong>同一基础类型的字面量联合类型， 其可以被认为是此基础类型的子类型</strong>， 即 <code>&#39;cqc&#39; | &#39;233&#39;</code> 是 string 的子类型</p><p>因此， 我们可以使用嵌套的条件类型来进行字面量类型到基础类型的提取:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">LiteralToPrimitive<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span>
 <span class="token operator">?</span> <span class="token builtin">string</span>
 <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">number</span></span>
 <span class="token operator">?</span> <span class="token builtin">number</span>
 <span class="token operator">:</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">bigint</span>
 <span class="token operator">?</span> bigint
 <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

 <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">universalAdd</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> bigint<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> LiteralToPrimitive<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token punctuation">(</span>y <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>


  <span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;233&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
  <span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token number">233</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
  <span class="token function">universalAdd</span><span class="token punctuation">(</span><span class="token number">10n</span><span class="token punctuation">,</span> <span class="token number">10n</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bigint</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>条件类型还可以用来对更复杂的类型进行比较， 比如函数类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">any</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">FunctionConditionType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Func<span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>
 <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span>
 <span class="token operator">?</span> <span class="token string">&#39;A string return func!&#39;</span>
 <span class="token operator">:</span> <span class="token string">&#39;A non-string return func&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r1</span> <span class="token operator">=</span> FunctionConditionType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// A string return func!</span>
<span class="token keyword">type</span> <span class="token class-name">r2</span> <span class="token operator">=</span> FunctionConditionType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// A non-string return func</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在这里， 我们的条件类型用于判断两个函数类型是否具有兼容性， 而条件中并不限制次数类型， 仅比较二者的返回值类型</p><p>与此同时， 存在泛型约束和条件类型两个 extends 可能会让你感到疑惑， 但他们产生作用的时机完全不同， 泛型约束要求你传入符合结构的类型参数， 相当于<strong>参数校验</strong>。 而条件类型使用类型参数进行条件判断（就像 if else）， 相当于<strong>实际内部逻辑</strong></p><h2 id="infer-关键字" tabindex="-1"><a class="header-anchor" href="#infer-关键字" aria-hidden="true">#</a> infer 关键字</h2><p>上面讲到的这些条件类型， 本质上就是在泛型基于调用填充类型信息的基础上， 新增了<strong>基于类型信息的条件判断</strong>。 看起来不错， 但你可能也发现了一个无法满足的场景： <div class="container" data-v-28f0c476><!--[-->提取传入的类型信息<!--]--></div></p><p>在上面的例子中， 假如我们不在比较填充的函数类型是否是 <code>(...args: any[]) =&gt; string</code> 的子类型， 而是要拿到其返回值类型呢？ 或者说， 我们希望拿到填充的类型信息的一部分， 而不是只是用它来做条件呢？</p><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><p>typescript 中支持通过 infer 关键字来 <div class="container" data-v-28f0c476><!--[-->在条件类型中提取类型的某一部分信息<!--]--></div>， 比如上面我们要提取函数返回值类型的话， 可以这么放：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">FunctionReturnType<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span></span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">(</span>
 <span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">infer</span> <span class="token constant">R</span>
 <span class="token operator">?</span> <span class="token constant">R</span>
 <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">t</span> <span class="token operator">=</span> FunctionReturnType<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>  <span class="token comment">// string</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>看起来是新朋友， 其实还是老伙计。 上面的代码表达了， 当传入的类型参数满足 <code>T extends (...args: any[]) =&gt; infer R</code> 这样一个结构（不用管 <code>infer R</code>, 当它是 any 就行）， 返回 <code>infer R</code> 位置的值， 即 R。 否则， 返回 never</p><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h3><p>这里的类型结构当然不局限于函数类型结构， 还可以是数组：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Swap<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token keyword">infer</span> <span class="token constant">A</span><span class="token punctuation">,</span> <span class="token keyword">infer</span> <span class="token constant">B</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r1</span> <span class="token operator">=</span> Swap<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;233&#39;</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 符合结构 替换首尾元素 [&#39;233&#39;, &#39;cqc&#39;]</span>
<span class="token keyword">type</span> <span class="token class-name">r2</span> <span class="token operator">=</span> Swap<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3]</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>由于我们声明的结构是一个仅有两个元素的元组， 因此三个元素的元组就被认为是不符合类型结构来。 但我们可以使用呢 rest 操作符来处理任意长度的情况：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">//提取首尾两个</span>
<span class="token keyword">type</span> <span class="token class-name">ExtractStartAndEnd<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>
 <span class="token keyword">infer</span> Start<span class="token punctuation">,</span>
 <span class="token operator">...</span><span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token keyword">infer</span> End
<span class="token punctuation">]</span>
 <span class="token operator">?</span> <span class="token punctuation">[</span>Start<span class="token punctuation">,</span> End<span class="token punctuation">]</span>
 <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">// 调换首尾两个</span>
<span class="token keyword">type</span> <span class="token class-name">SwapStartAndEnd<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>
 <span class="token keyword">infer</span> Start<span class="token punctuation">,</span>
 <span class="token operator">...</span><span class="token keyword">infer</span> Left<span class="token punctuation">,</span>
 <span class="token keyword">infer</span> End
<span class="token punctuation">]</span>
 <span class="token operator">?</span> <span class="token punctuation">[</span>End<span class="token punctuation">,</span> <span class="token operator">...</span>Left<span class="token punctuation">,</span> Start<span class="token punctuation">]</span>
 <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token comment">// 调换开头两个</span>
<span class="token keyword">type</span> <span class="token class-name">SwapFirstAndTwo<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span>
 <span class="token keyword">infer</span> First<span class="token punctuation">,</span>
 <span class="token keyword">infer</span> Second<span class="token punctuation">,</span>
 <span class="token operator">...</span><span class="token keyword">infer</span> Rest
<span class="token punctuation">]</span>
 <span class="token operator">?</span> <span class="token punctuation">[</span>Second<span class="token punctuation">,</span> First<span class="token punctuation">,</span> <span class="token operator">...</span>Rest<span class="token punctuation">]</span>
 <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">t1</span> <span class="token operator">=</span> ExtractStartAndEnd<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// [1, &#39;cqc&#39;]</span>
<span class="token keyword">type</span> <span class="token class-name">t2</span> <span class="token operator">=</span> SwapStartAndEnd<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// [&#39;cqc&#39;, 2, 1]</span>
<span class="token keyword">type</span> <span class="token class-name">t3</span> <span class="token operator">=</span> SwapFirstAndTwo<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// [2, 1, 3, 4]</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>是的， infer 甚至可以和 rest 操作符一样同时提取一组不定长的类型， 而 <code>...any[]</code> 的用法是否也让你直呼神奇？ 上面的输入输出仍然都是数组， 而实际上我们完全可以进行结构层面的转换。 比如从数组到联合类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ArrayItemType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> ElementType<span class="token operator">&gt;</span></span>
 <span class="token operator">?</span> ElementType
 <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">t1</span> <span class="token operator">=</span> ArrayItemType<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// never</span>
<span class="token keyword">type</span> <span class="token class-name">t2</span> <span class="token operator">=</span> ArrayItemType<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token keyword">type</span> <span class="token class-name">t3</span> <span class="token operator">=</span> ArrayItemType<span class="token operator">&lt;</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h3><p>infer 结构也可以是接口:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">PropType<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">K</span> <span class="token keyword">extends</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token punctuation">{</span>
 <span class="token punctuation">[</span>Key <span class="token keyword">in</span> <span class="token constant">K</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">infer</span> <span class="token constant">R</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 <span class="token operator">?</span> <span class="token constant">R</span>
 <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

 <span class="token comment">// 反转键名与键值</span>
<span class="token keyword">type</span> <span class="token class-name">ReverseKeyValue<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">unknown</span><span class="token operator">&gt;&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span>
 <span class="token keyword">infer</span> <span class="token constant">K</span><span class="token punctuation">,</span>
 <span class="token keyword">infer</span> <span class="token constant">V</span>
<span class="token operator">&gt;</span></span>
 <span class="token operator">?</span> Record<span class="token operator">&lt;</span><span class="token constant">V</span> <span class="token operator">&amp;</span> <span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span>
 <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>




<span class="token keyword">type</span> <span class="token class-name">t1</span> <span class="token operator">=</span> PropType<span class="token operator">&lt;</span>
 <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 <span class="token string">&#39;name&#39;</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>

<span class="token keyword">type</span> <span class="token class-name">t2</span> <span class="token operator">=</span> PropType<span class="token operator">&lt;</span>
 <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token string">&#39;age&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;name&#39;</span>
<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string | number</span>


<span class="token keyword">type</span> <span class="token class-name">t3</span> <span class="token operator">=</span> ReverseKeyValue<span class="token operator">&lt;</span><span class="token punctuation">{</span>
 name<span class="token operator">:</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// { cqc: &#39;name&#39; }</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>在这里， 为了体现 infer 作为类型工具的属性， 我们结合了索引类型与映射类型， 以及使用 <code>&amp; string</code> 来确保属性名作为 string 类型的小技巧。</p><p>为什么需要这个小技巧， 如果不使用会有什么问题吗？</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">ReverseKeyValue<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> Record<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token operator">&gt;&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">Record<span class="token operator">&lt;</span>
 <span class="token keyword">infer</span> <span class="token constant">K</span><span class="token punctuation">,</span>
 <span class="token keyword">infer</span> <span class="token constant">V</span>
<span class="token operator">&gt;</span></span>
 <span class="token operator">?</span> Record<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token punctuation">,</span> <span class="token constant">K</span><span class="token operator">&gt;</span>   <span class="token comment">// type &#39;V&#39; does not satisfy the constraint &#39;string | number | symbol&#39;.ts(2344)</span>
 <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>明明约束已经声明了 V 的类型是 string 为什么还是报错了</p><p>这是因为， 泛型参数 V 的来源是从键值类型推导出来的， typescript 中这样对键值类型进行 infer 推导， 将导致类型信息丢失， 而不满足索引签名类型只允许 <code>string | number | symbol</code> 的要求。</p><p>还记得映射类型的判断条件吗？ 需要同时满足其两端的类型， 我们使用 <code>V &amp; string</code> 这一形式，就确保了最终符合条件的类型参数 V 一定回满足 <code>string | never</code> 这个类型， 因此可以被视为合法的索引签名类型。</p><h3 id="promise" tabindex="-1"><a class="header-anchor" href="#promise" aria-hidden="true">#</a> Promise</h3><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">PromiseValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">V</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r1</span> <span class="token operator">=</span> PromiseValue<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">number</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
<span class="token keyword">type</span> <span class="token class-name">r2</span> <span class="token operator">=</span> PromiseValue<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>就像条件类型可以嵌套一样， infer 关键字也经常被使用在嵌套的场景中， 包括对类型结构深层信息的提取， 以及对提取到类型信息的筛选等。 比如上面的 PromiseValue， 如果传入了一个嵌套的 Promise 类型就失效了：</p><p>这时候我们就需要 进行嵌套的提取了：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">PromiseValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">R</span><span class="token operator">&gt;</span></span>
 <span class="token operator">?</span> <span class="token constant">R</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">N</span><span class="token operator">&gt;</span></span>
  <span class="token operator">?</span> <span class="token constant">N</span>
  <span class="token operator">:</span> <span class="token constant">R</span>
 <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>当然， 这个时候更应该使用递归来处理任意的嵌套深度：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">PromiseValue<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> PromiseValue<span class="token operator">&lt;</span><span class="token constant">V</span><span class="token operator">&gt;</span> <span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r</span> <span class="token operator">=</span> PromiseValue<span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;&gt;&gt;</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// string</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>条件类型在泛型的基础上支持了基于类型信息的动态条件判断， 但无法直接消费填充类型信息， 而 infer 关键字 则为他补上了这一部分能力， 让我们可以进行更多奇妙的类型操作， typescript 中内置的工具类型中还有一些基于 infer 关键字的应用， 后面我们会在内置工具类型讲解中了解它们的具体实现</p><h2 id="分布式条件类型" tabindex="-1"><a class="header-anchor" href="#分布式条件类型" aria-hidden="true">#</a> 分布式条件类型</h2><p>分布式条件类型听起来真的很高级， 但这里和分布式服务并不是一回事。 <strong>分布式条件类型， 也称作条件类型的分布式特性</strong>， 只不过是条件类型在满足一定情况下会执行的逻辑而已， 直接上例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Condition<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">?</span> <span class="token constant">T</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r1</span> <span class="token operator">=</span> Condition<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 1 | 2 | 3</span>

<span class="token keyword">type</span> <span class="token class-name">r2</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token keyword">extends</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span> <span class="token comment">// never</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这个例子可能让你充满了疑惑， 某些地方似乎和我们学习的知识并不一样？ 先不说这两个理论上应该执行结果一致的类型别名， 为什么在 r1 中诡异的返回了一个联合类型？</p><p>仔细观察就会发现， 唯一的差异就是在 r1 中， 进行判断的联合类型被作为泛型参数传入给另一个独立的类型别名， 而 r2 中直接对这两者进行判断。</p><blockquote><p>记住第一个差异： <div class="container" data-v-28f0c476><!--[-->是否通过泛型参数传入<!--]--></div>。</p></blockquote><p>我们在看一个例子：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Naked<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token string">&#39;Y&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;N&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Wrapped<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token string">&#39;Y&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;N&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r3</span> <span class="token operator">=</span> Naked<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;N&#39; | &#39;Y&#39;</span>
<span class="token keyword">type</span> <span class="token class-name">r4</span> <span class="token operator">=</span> Wrapped<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;N&#39;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>现在我们都是通过泛型参数传入了， 但诡异的事情又发生了， 为什么第一个还是个联合类型？ 第二个倒是好理解一些 元组的成员有可能是数字类型， 显然和 <code>[boolean]</code> 不兼容。</p><p>在仔细观察着两个例子你会发现， 它们唯一的差异就是条件类型中的 <strong>泛型参数是否被数组包裹了</strong></p><blockquote><p>第二个差异: <div class="container" data-v-28f0c476><!--[-->泛型参数是否被数组包裹了<!--]--></div></p></blockquote><p>同时, 你会发现在 r3 的判断中， 其联合类型的两个分支， 恰好对应分别使用 number 和 boolean 其作为条件类型判断时候的结果。</p><p>把上面的线索梳理一下， 其实我们就打值得到了条件类型分布式起作用的条件。</p><ul><li>首先， <strong>你的类型参数需要是一个联合类型。</strong></li><li>其次， <strong>类型参数需要通过泛型参数的方式传入， 而不能直接在外部进行判断（类似 r2）</strong></li><li>最后， <strong>条件类型中的泛型参数不能被包裹</strong></li></ul><p>而条件类型分布式特性会产生的效果也很明显了， 即将这个联合类型拆开来， 每个分支分别进行一次条件类型判断， 再将最后的结果合并起来（如 Naked 中）。 如果在严谨一些， 其实我们就得到了官方的解释：</p><p><strong>对于裸类型参数的检查类型， 条件类型会在实例化时期自动分发到联合类型上</strong>。</p><p>这里的自动分发， 我们可以这么理解：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Naked<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span> <span class="token operator">?</span> <span class="token string">&#39;Y&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;N&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// (number extends boolean ? &#39;Y&#39; : &#39;N&#39;) | (boolean extends boolean ? &#39;Y&#39; : &#39;N&#39;)</span>
<span class="token keyword">type</span> <span class="token class-name">r3</span> <span class="token operator">=</span> Naked<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;N&#39; | &#39;Y&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>写成伪代码其实就是这样的</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> Res3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> input <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token builtin">boolean</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">boolean</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Res3<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;Y&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    Res3<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;N&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>这里的裸类型参数， 其实指的就是泛型参数是否完全裸露， 我们上面使用数组包裹泛型参数只是其中一种方式， 比如还可以这么做：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">NoDistribute<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Wrapped<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> NoDistribute<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">boolean</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token string">&#39;Y&#39;</span> <span class="token operator">:</span> <span class="token string">&#39;N&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r</span> <span class="token operator">=</span> Wrapped<span class="token operator">&lt;</span><span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// &#39;N&#39;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>需要注意的是， 我们并不是智慧通过裸泛型参数， 来确保分布式特性能够发生。 在某些情况下， 我们也需要包括泛型参数来警用掉分布式特性。 最常见的场景也许还是联合类型的判断， 即我们不希望进行联合类型的兼容性判断，就像在最初的 r2 中那样.</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">CompareUnion<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> <span class="token constant">U</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">U</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r1</span> <span class="token operator">=</span> CompareUnion<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
<span class="token keyword">type</span> <span class="token class-name">r2</span> <span class="token operator">=</span> CompareUnion<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// false</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>通过将参数与条件都包裹起来的方式， 我们对联合类型的比较就变成了数组成员类型的比较， 在此时就会严格遵守类型层级一文中联合类型的类型判断了（子集为其子类型）</p><p>另外一种情况则是，当我们想判断一个类型是否为 never时候， 也可以通过类似的手段：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">IsNever<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">IsNeverRight<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">T</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token builtin">never</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">r1</span> <span class="token operator">=</span> IsNever<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// never</span>
<span class="token keyword">type</span> <span class="token class-name">r2</span> <span class="token operator">=</span> IsNever<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这里的原因其实并不是因为分布式条件类型。 我们此前在类型层级中了解过， 当条件的判断参数为 any， 会直接返回条件类型两个结果的联合类型。而在这里其实类似， 当通过泛型传入的参数为 never， 则会直接返回 never.</p><p>需要注意的是这里的 never 和 any 的情况并不完全相同， any 在直接<strong>作为判断参数时、作为泛型参数时</strong>都会产生这一效果：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 直接使用， 返回结果集的联合类型</span>
<span class="token keyword">type</span> <span class="token class-name">t1</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 1 | 2</span>

<span class="token comment">// 通过泛型参数传入， 同样返回结果集的联合类型</span>
<span class="token keyword">type</span> <span class="token class-name">t2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">t2Res</span> <span class="token operator">=</span> t2<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 1 | 2</span>

<span class="token comment">// 如果判断条件是 any 那么判断仍然会进行</span>
<span class="token keyword">type</span> <span class="token class-name">s1</span> <span class="token operator">=</span> <span class="token builtin">any</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>

<span class="token keyword">type</span> <span class="token class-name">s2<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">any</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">s2Res</span> <span class="token operator">=</span> s2<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>而 never 仅在作为泛型参数时才会产生:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 直接使用， 判断仍然会进行</span>
<span class="token keyword">type</span> <span class="token class-name">t3</span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>

<span class="token comment">// 当通过泛型参数传入， 会跳过判断 直接返回 never</span>
<span class="token keyword">type</span> <span class="token class-name">t4<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">string</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">t4Res</span> <span class="token operator">=</span> t4<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// never</span>

<span class="token comment">// 如果判断条件时 never， 还是仅在作为泛型参数时候才跳过判断</span>
<span class="token keyword">type</span> <span class="token class-name">s3</span> <span class="token operator">=</span> <span class="token builtin">never</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>

<span class="token keyword">type</span> <span class="token class-name">s4<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">never</span></span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">s4Res</span> <span class="token operator">=</span> s4<span class="token operator">&lt;</span><span class="token builtin">never</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// never</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这里的 any、 never 两种情况都不会实际地执行条件类型， 而在这里我们跳过包裹的方式让它不再是一个孤零零的 never， 也就可以去执行判断了。</p><p>之所以分布式条件类型要这么设计， 我个人理解主要是为了处理联合类型这种情况。 就像我们到现在为止的伪代码都一直使用数组来表达联合类型一样， 在类型世界中联合类型就像是一个集合一样。 通过使用分布式条件类型， 我们能轻易地进行集合之间的运算， 比如交集：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 与 A &amp; B 效果一致</span>
<span class="token keyword">type</span> <span class="token class-name">Intersection<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token constant">B</span></span> <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Intersection1<span class="token operator">&lt;</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">A</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token punctuation">[</span><span class="token constant">B</span><span class="token punctuation">]</span> <span class="token operator">?</span> <span class="token constant">A</span> <span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">IntersectionRes</span> <span class="token operator">=</span> Intersection<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 2 | 3</span>
<span class="token keyword">type</span> <span class="token class-name">IntersectionRes</span> <span class="token operator">=</span> Intersection1<span class="token operator">&lt;</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 1 | 2 | 3 (即 A)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>进一步的， 当联合类型的组成是一个对象的属性名（<code>keyof IObject</code>）, 此时对这样两个类型集合进行处理， 得到属性名的交集， 那我们就可以在此基础上获得两个对象结构的交集。 除此之外， 还有许多相对复杂的场景可以降纬到类型集合， 即联合类型的层面， 然后我们就可以愉快地使用分布式条件类型进行各种处理了。</p><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h2><p>上面我们通过 hack 的手段得到了 IsNever, 那你一定会想是否能实现 IsAny 与 IsUnknown ? 当然可以， 不过具体实现要稍微复杂一些， 并且并不完全依赖分布式条件类型</p><h3 id="isany" tabindex="-1"><a class="header-anchor" href="#isany" aria-hidden="true">#</a> IsAny</h3><p>上面已经提到了不能通过 <code>any extends type</code> 这样的形式来来判断一个类型是否 any。 而是要利用 any 的另一个特性： 深化万千：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">IsAny<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span> <span class="token keyword">extends</span> <span class="token string">&#39;qc&#39;</span> <span class="token operator">&amp;</span> <span class="token constant">T</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>&#39;cqc&#39; extends &#39;qc&#39;</code> 必然不成立， 而交叉类型 <code>&#39;qc&#39; &amp; T</code> 也很奇怪， 他意味着同时符合字面量类型 ‘cqc’ 和 字面量类型 &#39;qc&#39; 和另外一个类型 T. 在学习交叉类型时候我们已经了解到， 对于 &#39;cqc&#39; 这样的字面量类型， 只有传入其本身， 对应的原始类型, 包涵其本身的联合类型， 才能得到一个有意义的值， 并且这个值一定是它本身:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">t1</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">type</span> <span class="token class-name">t2</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">type</span> <span class="token class-name">t3</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
<span class="token keyword">type</span> <span class="token class-name">t4</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span><span class="token comment">// 1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>因为交叉类型就像<strong>短板效应一样， 其最终计算的类型是由最短的那根木板</strong>， 也就是最精确的那个类型决定的。 这样看， 无论如何 <code>&#39;cqc&#39; extends &#39;qc&#39;</code> 都不会成立。</p><p>但作为代表任意类型的 any， 他的存在就像是开天辟地的基本规则一样， 如果交叉类型中一个成员是 any， 那么短板效应就失效了， 此时最终类型必然是 any。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">t5</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&amp;</span> <span class="token builtin">any</span><span class="token punctuation">;</span> <span class="token comment">// any</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="isunknown" tabindex="-1"><a class="header-anchor" href="#isunknown" aria-hidden="true">#</a> IsUnknown</h3><p><code>unknown extends T</code> 时仅有 T 为 any 或者 unknown 时候， 这时候只需要直接判断 T 是不是 any 就好了:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">IsUnknown<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token builtin">unknown</span></span>
 <span class="token operator">?</span> IsAny<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token keyword">extends</span> <span class="token class-name"><span class="token boolean">true</span></span>
  <span class="token operator">?</span> <span class="token boolean">false</span>
  <span class="token operator">:</span> <span class="token boolean">true</span>
 <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/cqc-hub/vp-blob.io/tree/master/docs/typescript/k.条件类型与infer.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vp-blob.io/typescript/j.类型系统层级.html" class="" aria-label="j.类型系统层级"><!--[--><!--]--> j.类型系统层级 <!--[--><!--]--></a></span><span class="next"><a href="/vp-blob.io/typescript/l.工具类型.html" class="" aria-label="工具类型"><!--[--><!--]--> 工具类型 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vp-blob.io/assets/app.28445bf9.js" defer></script>
  </body>
</html>

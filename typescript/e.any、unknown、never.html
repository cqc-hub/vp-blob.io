<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/image/favicon.ico"><title></title><meta name="description" content="">
    <link rel="modulepreload" href="/vp-blob.io/assets/app.28445bf9.js"><link rel="modulepreload" href="/vp-blob.io/assets/e.any、unknown、never.html.6fb392b7.js"><link rel="modulepreload" href="/vp-blob.io/assets/e.any、unknown、never.html.657af7d7.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.8f018029.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.98776873.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.ec84774a.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.84c58d00.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fb44c11d.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.04557333.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.e4e771ef.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.64a103a2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3013be87.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.f33a1b79.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.f0357039.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.d4018bdd.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.fc637112.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.af7e2c7e.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.885a698a.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.f1da3f4b.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.71e96b0a.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.a8066bef.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.47b96db6.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a39bfc1a.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.2295a28e.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.3fb1f527.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.d26307e6.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.d7704ccc.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.a198ccc8.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.d5d366e2.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.9962dce2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fe25b76a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.a8456586.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.d6877f1b.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.16fd9c5f.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8ad5ee0.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.e57931a0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.224c5d9e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9483b910.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.21885604.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.afebf168.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.fbc2f79f.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.f5f2a306.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.a8e3ed93.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.4761e1bb.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.645f59cf.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.71743a0c.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.06f977a3.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.ffbf235f.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.03ab869d.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.24317708.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.21818278.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.a0e1348b.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.299f370c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.88fb9194.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.623e016f.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.f71f240c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.70643a0d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.fcb179b9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.a4126bf7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.b9b1e0ca.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.851b045e.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.60e43a8c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.761e4995.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.4c0328e0.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.5f3cb86a.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.8ff82f5e.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.7f1b0f8b.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.b86014e5.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.dba571f1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.c009c8d1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.06394c55.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.cd077274.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.4933004a.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.93146c89.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.0356a730.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9f9140e5.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.98256e4c.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.b052bd8a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3e37b7e7.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.6ff36268.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.b6b2b9e2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c874a8b5.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c3e042f2.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.7a317f56.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.2a865dab.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.311f0358.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.cf697cfd.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.398b4e97.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.037aad7d.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.1bd949ed.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.52ca17dd.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.f34fa417.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.e44fb0eb.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a09badfd.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.62415c6a.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.037e5a5d.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.013365b5.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.3b025d3c.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.e3e976e6.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.297e089b.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.861f9241.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.f748203e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.18ee491b.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.fcd2c4fb.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.9061575a.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8454023.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.0e8811b9.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c4c65b97.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.547bbfb0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3a04f0a9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.5e39c00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.8d1df225.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.0300e3da.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.4367c6e7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.52adde68.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.1119a5b8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.8c2848ad.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.343d643e.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.cc2b7662.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.8ecb2353.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.1063515b.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.8722a081.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.44ede00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.0bffe771.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.b1a0b6cc.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.83703e49.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.3139a078.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.c6c4dc0a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.036cd62d.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.cfc6577d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.f78bbe87.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.be63d1c8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.93776a99.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.b6fed70c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.bbc94483.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.a38026e9.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.92ecacce.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.644e2aab.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.fe27efa4.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.bd744455.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.b7f872e5.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.53627ba1.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.17ca2b9d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.0ceab273.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.a799acdf.js"><link rel="prefetch" href="/vp-blob.io/assets/404.008f7f9a.js"><link rel="prefetch" href="/vp-blob.io/assets/Layout.f041014c.js"><link rel="prefetch" href="/vp-blob.io/assets/Document.7ddbfa27.js"><link rel="prefetch" href="/vp-blob.io/assets/DocumentIntroduction.642e8662.js"><link rel="prefetch" href="/vp-blob.io/assets/FooBar.72140e24.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNav.c0863aa2.js"><link rel="prefetch" href="/vp-blob.io/assets/TypeScriptPrimitiveAndObject.723d323e.js"><link rel="prefetch" href="/vp-blob.io/assets/aMark.e9a27668.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNote.c64d23bd.js"><link rel="prefetch" href="/vp-blob.io/assets/MyHome.27c67e38.js">
    <link rel="stylesheet" href="/vp-blob.io/assets/style.f819ef42.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vp-blob.io/" class=""><img class="logo" src="/vp-blob.io/image/favicon.ico" alt><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#any、unknown、never" class="router-link-active router-link-exact-active sidebar-item" aria-label="any、unknown、never"><!--[--><!--]--> any、unknown、never <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#any-类型的使用" class="router-link-active router-link-exact-active sidebar-item" aria-label="any 类型的使用"><!--[--><!--]--> any 类型的使用 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#any、unknown-区别" class="router-link-active router-link-exact-active sidebar-item" aria-label="any、unknown 区别"><!--[--><!--]--> any、unknown 区别 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#never" class="router-link-active router-link-exact-active sidebar-item" aria-label="never"><!--[--><!--]--> never <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#类型断言" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型断言"><!--[--><!--]--> 类型断言 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#双重断言" class="router-link-active router-link-exact-active sidebar-item" aria-label="双重断言"><!--[--><!--]--> 双重断言 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#非空断言" class="router-link-active router-link-exact-active sidebar-item" aria-label="非空断言"><!--[--><!--]--> 非空断言 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vp-blob.io/typescript/e.any%E3%80%81unknown%E3%80%81never.html#扩展" class="router-link-active router-link-exact-active sidebar-item" aria-label="扩展"><!--[--><!--]--> 扩展 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><h2 id="any、unknown、never" tabindex="-1"><a class="header-anchor" href="#any、unknown、never" aria-hidden="true">#</a> any、unknown、never</h2><p>ts 提供了一个内置类型 any， 来表示所谓的任意类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token operator">...</span>optionalParams<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这里， 一个被标记为 any类型 的参数可以接受任意类型的值。除了 message 是any以外， optionalParams 作为一个reset参数， 也使用 <div class="container" data-v-28f0c476><!--[-->any[]<!--]--></div> 进行了标记， 这就意味着你可以使用任意类型的任意数量类型来调用这个方法。 除了显式的标记了一个变量或参数为 any，在某些情况下 你的变量/参数也会被隐式地推导为any。 比如使用 let 声明一个变量但是不提供初始值， 以及不为函数参数提供类型标注:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// any</span>
<span class="token keyword">let</span> foo<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  params <span class="token comment">//any</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>以上函数声明在 tsconfig 中启用了 <div class="container" data-v-28f0c476><!--[-->noImplicitAny<!--]--></div> 时会报错， 你可以显式为这两个参数指定 any 类型， 或暂时关闭这一配置（不推荐）。 而 any 类型的变量几乎 无所不能， 他可以在声明后再次接受任意类型的值， 同时可以被赋值给其他任意类型的变量:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 被标记为 any 类型的变量可以拥有任意类型的值</span>
<span class="token keyword">let</span> anyVar<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>

anyVar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
anyVar <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span>
<span class="token function-variable function">anyVar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>

<span class="token comment">// 标记为具体类型的变量也可以接受任何 any 的参数可以接受任意类型的值</span>
<span class="token keyword">const</span> val1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> anyVar<span class="token punctuation">;</span>
<span class="token keyword">const</span> val2<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> anyVar<span class="token punctuation">;</span>
<span class="token keyword">const</span> val3<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> anyVar<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>你可以在 any 类型变量上任意地进行操作， 包括赋值、访问、方法调用等等， 此时可以认为类型推导与检查时被完全禁用的：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> anyVar<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

anyVar<span class="token punctuation">.</span>foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
anyVar<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>prop1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>any 类型的主要意义， 其实就是为了表示一个 <strong>无拘无束的“任意类型”，他能兼容所有类型，也能被所有类型兼容</strong>。 这一作用其实也意味着类型世界给你开了一个外挂， 无论什么时候， 你都可以使用 any 类型跳过类型检查。 当然，运行时候出现问题就需要自己负责.</p><blockquote><p>any 的本质是类型系统中的顶级类型， 即 Top Type， 这是许多类型语言中的重要概念。</p></blockquote><h3 id="any-类型的使用" tabindex="-1"><a class="header-anchor" href="#any-类型的使用" aria-hidden="true">#</a> any 类型的使用</h3><p>any 类型的万能性也导致我们经常滥用它， 比如类型不兼容了就 any 一下， 类型不想写了也 any 一下， 不确定可能是啥类型 还是 any 一下。 此时 TypeScript 就变成了令人诟病的 AnyScript. 为了避免这一情况， 我们需要记住一下使用小 tips：</p><ul><li>如果类型不兼容报错导致你使用 any， 考虑使用类型断言代替</li><li>如果是类型太复杂到值你不想全部声明而使用 any， 考虑将这一出的类型去断言为你需要的最简类型。 如你需要调用 <div class="container" data-v-28f0c476><!--[-->foo.bar.baz()<!--]--></div>, 就可以先将 foo 断言为一个具有 baz 方法的类型。</li><li>如果你是想表达一个未知类型， 更合理的方式是使用 unknown。</li></ul><p>unknown 类型和 any 类型有些类似， 一个 unknown 类型的变量可以再次赋值为任意其他类型， 但只能赋值给 any 与 unknown 类型的变量:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 可以再次赋值为任意其他类型</span>
unknownVar <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
unknownVar <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&#39;cqc&#39;</span>
<span class="token punctuation">}</span>
<span class="token function-variable function">unknownVar</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>


<span class="token keyword">const</span> val1<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> unknownVar<span class="token punctuation">;</span> <span class="token comment">//error</span>
<span class="token keyword">const</span> val2<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> unknownVar<span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token keyword">const</span> <span class="token function-variable function">val3</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> unknownVar<span class="token punctuation">;</span> <span class="token comment">// error</span>
<span class="token comment">// ...</span>


<span class="token comment">// 但只能赋值给 any 与 unknown 类型的变量</span>
<span class="token keyword">const</span> val4<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> unknownVar<span class="token punctuation">;</span>
<span class="token keyword">const</span> val5<span class="token operator">:</span> <span class="token builtin">unknown</span> <span class="token operator">=</span> unknownVar<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="any、unknown-区别" tabindex="-1"><a class="header-anchor" href="#any、unknown-区别" aria-hidden="true">#</a> any、unknown 区别</h3><p>any 与 unknown 的一个主要差异体现在赋值给别的变量时候， any 就像是 <strong>我身化万千无处不在</strong>, 所有类型都把它当自己人。 而 unknown 就像是 <strong>我虽身化万千， 但我坚信我在未来的某一刻会得到一个确定的类型</strong>, 只有 any 和 unknown 自己把它当自己人.</p><p>简单的说， any 放弃了所有的类型检查， 而 unknown 没有。 这一点也体现在对 unknown 类型的变量进行了属性访问时候:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span>

unknownVar<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错： 对象类型为 unknown</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>要对 unknown 类型进行属性访问， 需要进行类型断言， 即“虽然这是一个未知的类型， 但我保证它在这里就是这个类型”</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>unknownVar <span class="token keyword">as</span> <span class="token punctuation">{</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在类型未知的情况下， 更推荐使用 unknown 标注。 这相当你使用额外的心智负担保证了类型在各处的结构， 后续重构为具体类型时也可以获得最初始的类型休息， 同时还保证了类型检查的存在。</p><p>当然， unknown 使用起来很麻烦， 一堆类型断言写起来可不太好看。 归根结底， 到底使用哪个完全取决于你自己， 毕竟语言只是工具嘛。</p><h2 id="never" tabindex="-1"><a class="header-anchor" href="#never" aria-hidden="true">#</a> never</h2><p>never 就是一个什么都没有的类型， 和 void 类似， 但相比于 void ， never 还要更加彻底一点:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// &#39;cqc&#39; | 599 | true | void</span>
<span class="token keyword">type</span> <span class="token class-name">UnionWithNever</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span> <span class="token operator">|</span> <span class="token number">599</span> <span class="token operator">|</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token keyword">void</span> <span class="token operator">|</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>将鼠标挪动类型别名上， 你会发现这里显示的类型上 <div class="container" data-v-28f0c476><!--[-->&#39;cqc&#39; | 599 | true | void<!--]--></div> . never 类型直接被无视掉了， 而 void 仍然存在。 这是因为， void 作为类型表示一个空类型， 就像没有返回值的函数使用 void 来作为返回值类型标注一样， void 类型就像 javascript 中的 null 一样代表“ 这里有类型， 但是个空类型”。</p><p>而 never 才是一个 “什么都没有” 的类型， 它甚至不包括空的类型， 严格来说， <strong>never 类型不携带任何的类型信息</strong>， 因此会在联合类型中被直接移除， 比如我们看 void 和 never 的类型兼容性:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">let</span> v1<span class="token operator">:</span> <span class="token builtin">never</span><span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> v2<span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span> <span class="token comment">// X 类型 void 不能赋值给类型 never</span>

v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在编程语言的类型系统中， never 类型被称为 <strong>Bottom Type</strong>， 是<strong>整个类型系统层级中最底层的类型</strong>， 和 null、 undefined 一样， 它是所有类型的子类型， 但只有 never 类型的变量能够赋值给另一个 never 类型变量。</p><p>通常我们不会显式的声明一个 never 类型， 它主要被类型检查所使用。 但在某些情况下使用 never 确实是符合逻辑的， 比如一个只负责抛出错误的函数：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">justThrrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在类型流的分析中， 一旦一个返回值为 never 的函数被调用， 那么下方的代码都会被视为无效的代码（即无法执行到）：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">justThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">never</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>input <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">justThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 等同于 return 语句后面的代码， 即 dead code</span>
    <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>我们可以显示的利用它来进行类型检查， 即上面在联合类型中 never 类型神秘消失的原因。 假设，我们需要对一个联合类型的每个类型分枝进行不同处理：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">const</span> strOrNumOrBool<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;boolean&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;boolean&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;unknown input type: &#39;</span> <span class="token operator">+</span> strOrNumOrBool<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>如果我们希望这个变量的每一种类型都需要得到妥善处理， 在最后可以抛出一个错误， 但这是只有运行时候 才会生效的措施， 是否能在类型检查时候就分析出来？</p><p>实际上， 由于 TypeScript 强大的类型分析能力， 每经过一个 if 语句处理， <div class="container" data-v-28f0c476><!--[-->strOrNumOrBool<!--]--></div> 的类型分枝就会减少一个。 而在最后的 else 代码块中， 它的类型就只剩下了 nerve 类型， 即一个无法再细分、本质上并不存在的虚空类型。在这里， 我们可以利用 never 类型变量仅能 赋值给 never 类型变量的特性， 来巧妙地分支处理检查：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 一定是 string</span>
  strOrNumOrBool<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strOrNumOrBool<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;boolean&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  strOrNumOrBool <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> _exhaustiveCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> strOrNumOrBool<span class="token punctuation">;</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;unknown input type: &#39;</span> <span class="token operator">+</span> strOrNumOrBool<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>假如某个粗心的同事新增了一个类型分支， <div class="container" data-v-28f0c476><!--[-->strOrNumOrBool<!--]--></div> 变成了 <div class="container" data-v-28f0c476><!--[-->strOrNumOrBoolOrFunc<!--]--></div> 却忘记了新增对应的处理分支， 此时在 else 代码块中就会出现将 Function 类型赋值给 never 类型变量的类型错误。</p><p>这实际就是利用了类型分析能力与 never 类型只能赋值给 never 这一点， 来确保联合类型能够被妥善处理。</p><p>除了主动使用 never 类型的两种方式， never 在某些情况下还会不请自来：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 类型 string 不能赋值给 类型 never 的参数</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此时这个未标明类型的数组被推导为了 <div class="container" data-v-28f0c476><!--[-->never[]<!--]--></div> 类型， 这种情况仅会在你启用了 <div class="container" data-v-28f0c476><!--[-->strictNotNullChecks<!--]--></div> 配置， 同时禁用了 <div class="container" data-v-28f0c476><!--[-->noImplicitAny<!--]--></div> 配置时候才会出现。 解决这个问题也很简单， 为这个数组声明一个具体类型即可。</p><h2 id="类型断言" tabindex="-1"><a class="header-anchor" href="#类型断言" aria-hidden="true">#</a> 类型断言</h2><p>警告编译器不准报错， 类型断言能显示的告诉类型检查程序当前这个变量的类型， 可以进行类型分析地修正、类型。 它其实就是一个将变量的已有类型更改为新指定类型的操作， 它的基本语法为 <div class="container" data-v-28f0c476><!--[-->as NewType<!--]--></div>, 你可以将 any/unknown 类型断言到一个具体类型</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">let</span> unknownVar<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>unknownVar <span class="token keyword">as</span> <span class="token punctuation">{</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>还可以 as 到 any 来为所欲为， 跳过所有的类型检查:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foo<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>也可以在联合类型断言一个具体的分支:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>union<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>union <span class="token keyword">as</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token punctuation">}</span>


  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>union <span class="token keyword">as</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">599</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>但是类型断言的正确打开方式是， 在 TypeScript 类型分析不正确或不符合预期时候， 将其断言为此处的正确类型:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">IFoo</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">const</span> obj<span class="token operator">:</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> IFoo
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">as</span> IFoo
<span class="token punctuation">}</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这里从 <div class="container" data-v-28f0c476><!--[-->{}<!--]--></div> 字面量类型断言为了 <div class="container" data-v-28f0c476><!--[-->IFoo<!--]--></div> 类型, 即为解构赋值默认值进行了预期的类型断言。 当然， 更严谨的方式应该是定义为 <code>Partial&lt;IFoo&gt;</code> 类型。</p><p>除了使用 as 语法以外， 你也可以使用 <code>&lt;&gt;</code> 语法。 它虽然书写更简洁， 但效果一致， 只是在 tsx 中尖括号并不能很好的被分析出来。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span>arg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>你也可以通过 TypeScript ESLint 提供的 <div class="container" data-v-28f0c476><!--[-->consistent-type-assertions<!--]--></div> 规则来约束断言风格。</p><p>需要注意的是， 类型断言应当是在迫不得已的情况下使用的。 虽然说我们可以用类型断言纠正不正确的类型分析， 但类型分析在 大部分场景下还是可以智能地满足我们的需求的。</p><p>总的来说， 在实际场景中， 还是 <div class="container" data-v-28f0c476><!--[-->as any<!--]--></div> 这一操作更多。 但这也是让你的代码编程 AnyScript 的罪魁祸首之一， 请务必小心使用.</p><h3 id="双重断言" tabindex="-1"><a class="header-anchor" href="#双重断言" aria-hidden="true">#</a> 双重断言</h3><p>如果在使用类型断言时候， 原类型与断言类型之间差异过大， 也就算指鹿为马太过离谱， 离谱到了指鹿为霸王龙的程度， TypeScript 会给你 一个类型报错</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 从 x 类型到 y 类型到断言可能是错误的， blabla</span>
<span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token punctuation">{</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>此时他会提醒你先断言道 unknown 类型， 在断言到 预期类型， 就像这样：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> str<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>

<span class="token punctuation">(</span>str <span class="token keyword">as</span> <span class="token builtin">unknown</span> <span class="token keyword">as</span> <span class="token punctuation">{</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 尖括号断言</span>
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这是因为你的断言类型和原类型的差异太大， 需要先断言到一个通用的类， 即 any/unknown。 这一通用类型包含了所有可能的类型， 因此<strong>断言到它和从它断言到另一个类型</strong>的差异不大。</p><h3 id="非空断言" tabindex="-1"><a class="header-anchor" href="#非空断言" aria-hidden="true">#</a> 非空断言</h3><p>非空断言其实是类型断言的简化， 它使用<div class="container" data-v-28f0c476><!--[-->!<!--]--></div> 语法， 即 <div class="container" data-v-28f0c476><!--[-->obj!.func()!.prop<!--]--></div> 的形式 标记前面的一个声明一定是非空的（实际上就是剔除了 null 和 undefined 类型）</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token operator">:</span> <span class="token punctuation">{</span>
  func<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    prop<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

foo<span class="token punctuation">.</span>func<span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>prop<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>其应用位置类似于可选链<code>foo.func?.().prop?.toFixed()</code>, 但不同的是， 非空断言的运行时仍然会保持调用链， 因此在运行时候可能会报错。 而可选链则会在某一部分收到 undefined 或 null 时候直接短路掉， 不会再发生后面的调用。</p><p>你可以通过 <div class="container" data-v-28f0c476><!--[-->non-nullable-type-assertion-style<!--]--></div> 规则来检查代码中是否存在类型断言能够被简写为非空断言的情况。</p><p>类型断言还用一种用法上作为代码提示的辅助工具， 比如对于下面这个稍微复杂的接口：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">IStruct</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  bar<span class="token operator">:</span> <span class="token punctuation">{</span>
    barPropA<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    barPropB<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    <span class="token function-variable function">barMethodL</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    baz<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>假设你想要基于这个结构随便实现一个对象</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> obj<span class="token operator">:</span> IStruct <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这时候等你的是 一堆类型报错， 你必须规规整整地实现这个接口才可以。 但如果使用类型断言， 我们可以在 保留类型提示的前提下， 不那么完整地实现这个结构:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token operator">&lt;</span>IStruct<span class="token operator">&gt;</span><span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 仍有类型提示， 错误实现时候仍有 报错信息</span>
    baz<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h2><p>这一章节讲的其实都和 TypeScript 的类型层级有所关联, 前面讲到过， any 与 unknown 属于 <strong>Top Type</strong>, 表现在它们包含了所有可能的类型， 而 never 属于 <strong>Bottom Type</strong>， 表现在它是一个虚无的、不存在的类型。那么加上此前学习的原始类型与字面量类型等， 按照类型的包含来进行划分， 我们大概能够梳理出这么个类型层级关系：</p><ul><li>最顶级的类型 any、unknown</li><li>特殊的 Object， 它也包含了所有的类型, 但和 Top Type 比较还是差了一层</li><li>String、Boolean、Number 这些装箱类型</li><li>原始类型与对象类型</li><li>字面量类型，即更精确的原始类型与对象类型， 需要注意的是 null、 undefined 并不是字面量类型的子类型</li><li>最底层的never</li></ul><blockquote><p>实际上这个层级链并不完全， 因为还有联合类型、交叉类型、 函数类型的情况， 后面会讲到</p></blockquote><p>而实际上类型断言的工作原理也和类型层级有关，在判断断言是否成立，即差异是否能接受时， 实际上判断的即是这两个类型是否能够找到一个公共的父类型. 比如 <div class="container" data-v-28f0c476><!--[-->{ }<!--]--></div> 和 <div class="container" data-v-28f0c476><!--[-->{ name: string }<!--]--></div> 其实可以认为拥有公共的父类型 <div class="container" data-v-28f0c476><!--[-->{ }<!--]--></div> (一个新的 <div class="container" data-v-28f0c476><!--[-->{ }<!--]--></div>, 你可以理解为这是一个基类， 参与断言的 <code>{ }</code> 和 <code>{ name: string; }</code> 是它的派生类。 )</p><p>如果找不到具有意义的公共父类型呢？ 这时候就需要请出 <strong>Top Type</strong> 了， 先把它断言到 <strong>Top Type</strong>， 那么就拥有了公共父类型<strong>Top Type</strong>， 在 断言到具体类型也是同理。 你可以理解为先向上断言，再向下断言。</p><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/cqc-hub/vp-blob.io/tree/master/docs/typescript/e.any、unknown、never.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vp-blob.io/typescript/d.函数重载与Class.html" class="" aria-label="d.函数重载与Class"><!--[--><!--]--> d.函数重载与Class <!--[--><!--]--></a></span><span class="next"><a href="/vp-blob.io/typescript/f.类型工具(part 1).html" class="" aria-label="f.类型工具(part 1)"><!--[--><!--]--> f.类型工具(part 1) <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vp-blob.io/assets/app.28445bf9.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/image/favicon.ico"><title></title><meta name="description" content="">
    <link rel="modulepreload" href="/vp-blob.io/assets/app.28445bf9.js"><link rel="modulepreload" href="/vp-blob.io/assets/r.类型声明命名空间.html.297e089b.js"><link rel="modulepreload" href="/vp-blob.io/assets/r.类型声明命名空间.html.d5d366e2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.8f018029.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.98776873.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.ec84774a.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.84c58d00.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fb44c11d.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.04557333.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.e4e771ef.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.64a103a2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3013be87.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.f33a1b79.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.f0357039.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.d4018bdd.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.fc637112.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.657af7d7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.af7e2c7e.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.885a698a.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.f1da3f4b.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.71e96b0a.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.a8066bef.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.47b96db6.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a39bfc1a.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.2295a28e.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.3fb1f527.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.d26307e6.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.d7704ccc.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.a198ccc8.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.9962dce2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fe25b76a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.a8456586.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.d6877f1b.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.16fd9c5f.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8ad5ee0.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.e57931a0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.224c5d9e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9483b910.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.21885604.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.afebf168.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.fbc2f79f.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.f5f2a306.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.a8e3ed93.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.4761e1bb.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.645f59cf.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.71743a0c.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.06f977a3.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.ffbf235f.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.03ab869d.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.24317708.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.21818278.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.a0e1348b.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.299f370c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.88fb9194.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.623e016f.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.f71f240c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.70643a0d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.fcb179b9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.a4126bf7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.b9b1e0ca.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.851b045e.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.60e43a8c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.761e4995.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.4c0328e0.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.5f3cb86a.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.8ff82f5e.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.7f1b0f8b.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.b86014e5.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.dba571f1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.c009c8d1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.06394c55.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.cd077274.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.4933004a.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.93146c89.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.0356a730.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9f9140e5.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.98256e4c.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.b052bd8a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3e37b7e7.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.6ff36268.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.b6b2b9e2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c874a8b5.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c3e042f2.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.7a317f56.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.2a865dab.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.311f0358.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.cf697cfd.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.6fb392b7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.398b4e97.js"><link rel="prefetch" href="/vp-blob.io/assets/g.类型工具(part 2).html.037aad7d.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.1bd949ed.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.52ca17dd.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.f34fa417.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.e44fb0eb.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a09badfd.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.62415c6a.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.037e5a5d.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.013365b5.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.3b025d3c.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.e3e976e6.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.861f9241.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.f748203e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.18ee491b.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.fcd2c4fb.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.9061575a.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8454023.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.0e8811b9.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c4c65b97.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.547bbfb0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3a04f0a9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.5e39c00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.8d1df225.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.0300e3da.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.4367c6e7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.52adde68.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.1119a5b8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.8c2848ad.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.343d643e.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.cc2b7662.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.8ecb2353.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.1063515b.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.8722a081.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.44ede00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.0bffe771.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.b1a0b6cc.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.83703e49.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.3139a078.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.c6c4dc0a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.036cd62d.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.cfc6577d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.f78bbe87.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.be63d1c8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.93776a99.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.b6fed70c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.bbc94483.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.a38026e9.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.92ecacce.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.644e2aab.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.fe27efa4.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.bd744455.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.b7f872e5.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.53627ba1.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.17ca2b9d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.0ceab273.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.a799acdf.js"><link rel="prefetch" href="/vp-blob.io/assets/404.008f7f9a.js"><link rel="prefetch" href="/vp-blob.io/assets/Layout.f041014c.js"><link rel="prefetch" href="/vp-blob.io/assets/Document.7ddbfa27.js"><link rel="prefetch" href="/vp-blob.io/assets/DocumentIntroduction.642e8662.js"><link rel="prefetch" href="/vp-blob.io/assets/FooBar.72140e24.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNav.c0863aa2.js"><link rel="prefetch" href="/vp-blob.io/assets/TypeScriptPrimitiveAndObject.723d323e.js"><link rel="prefetch" href="/vp-blob.io/assets/aMark.e9a27668.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNote.c64d23bd.js"><link rel="prefetch" href="/vp-blob.io/assets/MyHome.27c67e38.js">
    <link rel="stylesheet" href="/vp-blob.io/assets/style.f819ef42.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vp-blob.io/" class=""><img class="logo" src="/vp-blob.io/image/favicon.ico" alt><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#类型检查指令" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型检查指令"><!--[--><!--]--> 类型检查指令 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#ts-ignore-、-ts-expect-error-单行检查" class="router-link-active router-link-exact-active sidebar-item" aria-label="ts-ignore 、 ts-expect-error （单行检查）"><!--[--><!--]--> ts-ignore 、 ts-expect-error （单行检查） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#ts-check-、-ts-nocheck-整个文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="ts-check 、 ts-nocheck (整个文件)"><!--[--><!--]--> ts-check 、 ts-nocheck (整个文件) <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#类型声明" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型声明"><!--[--><!--]--> 类型声明 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#让类型定义全面覆盖你的项目" class="router-link-active router-link-exact-active sidebar-item" aria-label="让类型定义全面覆盖你的项目"><!--[--><!--]--> 让类型定义全面覆盖你的项目 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#definitelytyped" class="router-link-active router-link-exact-active sidebar-item" aria-label="DefinitelyTyped"><!--[--><!--]--> DefinitelyTyped <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#扩展已有的类型定义" class="router-link-active router-link-exact-active sidebar-item" aria-label="扩展已有的类型定义"><!--[--><!--]--> 扩展已有的类型定义 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#三斜线指令" class="router-link-active router-link-exact-active sidebar-item" aria-label="三斜线指令"><!--[--><!--]--> 三斜线指令 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#namespace-命名空间" class="router-link-active router-link-exact-active sidebar-item" aria-label="namespace 命名空间"><!--[--><!--]--> namespace 命名空间 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#扩展" class="router-link-active router-link-exact-active sidebar-item" aria-label="扩展"><!--[--><!--]--> 扩展 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/r.%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4.html#通过-jsdoc-在-js-文件中获得类型提示" class="router-link-active router-link-exact-active sidebar-item" aria-label="通过 JSDoc 在 js 文件中获得类型提示"><!--[--><!--]--> 通过 JSDoc 在 js 文件中获得类型提示 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><p>这里主要聊 typescript 的实战</p><h2 id="类型检查指令" tabindex="-1"><a class="header-anchor" href="#类型检查指令" aria-hidden="true">#</a> 类型检查指令</h2><p>在前端世界的许多工具中，其实都提供了<strong>行内注释</strong>的能力，用于支持在某一处特定代码<strong>使用特殊的配置来覆盖全局配置</strong>。 最常见的即是 ESlint、Prettier 提供的禁用检查能力，如 <code>/* eslint-disable-next-lint */</code> , <code>prettier-ignore</code> 等。</p><p>typescript 中同样提供了数个行内注释（我们称为类型指令）， 来进行单行代码或单文件级别的配置能力。 这些指令均以 <code>// @ts-</code> 开头：</p><h3 id="ts-ignore-、-ts-expect-error-单行检查" tabindex="-1"><a class="header-anchor" href="#ts-ignore-、-ts-expect-error-单行检查" aria-hidden="true">#</a> ts-ignore 、 ts-expect-error （单行检查）</h3><p><code>ts-ignore</code> 应该是使用最为广泛的一个类型指令了， 他的作用就是直接禁用掉对下一行代码的类型检查</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @ts-ignore</span>
<span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span> <span class="token comment">// 不会报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>基本上所有的类型报错都可以通过这个指令来解决，但由于它本质上是 ignore 而不是 disable， 也就意味着如果下一行代码没有问题， 那使用 ignore 反而是一个错误了。 因此 typescript 随后又引入了一个更严格版本的 ignore， 即 <code>ts-expect-error</code>, 它只有在 <strong>下一行代码真的存在错误时</strong> 才能被引用， 否则它会给出一个错误：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @ts-expect-error</span>
<span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>

<span class="token comment">// @ts-expect-error 错误使用此指令，报错 (书上说的， 实际上我电脑并没有)</span>
<span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">599</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在这里第二个 expect-error 指令会给出一个报错：无意义的 expect-error 指令。</p><blockquote><p>总结： <strong>在所有地方都不要使用 ts-ignore</strong>， 直接把这个指令打入冷宫封存起来（使用 expect-error 代替）, 对于 ignore 指令， 本来就应当确保<strong>下一行真的存在错误时候</strong>才去使用。</p></blockquote><h3 id="ts-check-、-ts-nocheck-整个文件" tabindex="-1"><a class="header-anchor" href="#ts-check-、-ts-nocheck-整个文件" aria-hidden="true">#</a> ts-check 、 ts-nocheck (整个文件)</h3><p>使用了 ts-nocheck 指令的 ts 文件将不在接受类型检查：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @ts-nocheck  以下代码均不会抛出错误</span>
<span class="token keyword">const</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> age<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>那么 <code>ts-check</code> 呢? 这看起来是一个多余的指令， 因为默认 ts 文件不是就会被检查嘛。 但实际上 ，这两个指令还可以用在 js 文件中。 要明白这一点， 首先我们要知道， typescript 并不是只能检查 ts 文件， 对于 js 文件它也可以通过类型推导 与 JSDoc 的方式进行不完全的类型检查。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// js 文件</span>
<span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 JSDoc 标注变量类型</span>
<span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span> string <span class="token punctuation">}</span></span> */</span>
<span class="token keyword">let</span> myName<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 prop <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上面代码中， 声明了初始值的 myAge、Foo.prop 都能被推导除其类型， 而无初始值的 myName 也可以通过 JSDoc 标注的方式来显示的标注类型。</p><p>但是 js 是弱类型语言， 表现之一即是变量可以<strong>被赋值为与初始值类型不一致的值</strong> ：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// js 文件</span>
<span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 JSDoc 标注变量类型</span>
<span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span> string <span class="token punctuation">}</span></span> */</span>
<span class="token keyword">let</span> myName<span class="token punctuation">;</span>

<span class="token comment">// 不会报错</span>
myAge <span class="token operator">=</span> <span class="token string">&#39;233&#39;</span><span class="token punctuation">;</span>
myName <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>我们的赋值操作在类型层面显然是不成立的， 但是是在 js 文件中， 因此这里并不会有类型报错。 如果希望在 js 文件中也能享受到类型检查， 此时 <code>ts-check</code> 指令就可以登场了:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// @ts-check</span>

<span class="token keyword">let</span> myAge <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 JSDoc 标注变量类型</span>
<span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span> string <span class="token punctuation">}</span></span> */</span>
<span class="token keyword">let</span> myName<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 prop <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

myAge <span class="token operator">=</span> <span class="token string">&#39;233&#39;</span><span class="token punctuation">;</span> <span class="token comment">// error</span>

<span class="token comment">// @ts-expect-error</span>
myName <span class="token operator">=</span> <span class="token number">233</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><code>ts-nocheck</code> 在 js 文件中的作用和 ts 文件其实也一致， 即禁用掉对当前文件的检查。 如果我们希望开启对所有 js 文件的检查， 而只是忽略掉其中少数呢？ 此时我们在 TSConfig 中启用 <code>checkJs</code> 的配置， 来开启<strong>对所有包含的js文件的类型检查</strong>， 然后使用 <code>ts-nocheck</code> 来忽略其中少数的js 文件</p><h2 id="类型声明" tabindex="-1"><a class="header-anchor" href="#类型声明" aria-hidden="true">#</a> 类型声明</h2><p>在此前我们其实就以及接触了类型声明， 它实际上就是 <code>declare</code> 语法:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">var</span> <span class="token function-variable function">f1</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>input<span class="token operator">:</span> Foo<span class="token punctuation">)</span><span class="token operator">:</span> Foo<span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>但不能为这些声明变量赋值：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// error 不允许在环境上下文中使用初始值</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// yes</span>
<span class="token keyword">declare</span> <span class="token keyword">let</span> result<span class="token operator">:</span> ReturnType<span class="token operator">&lt;</span><span class="token keyword">typeof</span> foo<span class="token operator">&gt;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这些类型声明就像我们在 typescript 中的类型标注一样， 会存放着特定的类型信息， 同时由于它们并不具有实际逻辑， 我们可以很方便的使用类型声明来进行类型兼容性的比较、 工具类型的声明、测试等等。</p><p>除了手动书写这些声明文件， 更常见的情况是你的 typescript 代码在编译后生成的声明文件：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 源代码</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=&gt;</span> input<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo<span class="token operator">:</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">23</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">FooCls</span> <span class="token punctuation">{</span>
  prop<span class="token operator">!</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>这段代码在编译后会生成一个 <code>.js</code> 文件和一个 <code>.d.ts</code> 文件， 而后者即是类型声明文件：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">const</span> foo<span class="token operator">:</span> Foo<span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">class</span> <span class="token class-name">FooCls</span> <span class="token punctuation">{</span>
  prop<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这样一来， 如果别的文件或是别的项目导入了这段代码， 它们就能从这些类型声明获得对应部分的类型，这也是类型声明的核心作用：<strong>将类型独立于<code>.js</code>文件进行存储</strong>. 别人在使用你的代码时候， 就能获得这些额外的类型信息。 同时， 如果你在使用别人没有携带类型声明的 <code>.js</code> 文件， 也可以通过类型声明进行类型补全。</p><h2 id="让类型定义全面覆盖你的项目" tabindex="-1"><a class="header-anchor" href="#让类型定义全面覆盖你的项目" aria-hidden="true">#</a> 让类型定义全面覆盖你的项目</h2><p>在学习下面的内容前， 不妨先想想你是否遇到过这么几个场景？</p><ul><li><p>想要使用一个 npm 包， 但他发布的时间太早， 根本没有携带类型定义， 于是你的项目里就出现了这么一处没有被类型覆盖的地方。</p></li><li><p>你想要在代码里导入一些非代码文件， 反正 Webpack 会帮你处理， 但是可恶的 ts 又报错了？</p></li><li><p>这个项目在运行时动态注入了一些全局变量（如 <code>window.errorReporter</code>）, 你想要在代码里直接这样访问， 却发现类型又报错了</p></li></ul><p>这些问题都可以通过类型声明来解决， 这也是他的核心能力， <strong>通过额外的类型声明文件， 在核心代码文件以外去提供对类型的进一步补全</strong>。 类型声明文件， 即 <code>.d.ts</code> 结尾的文件， 它会自动地被 ts 加载到环境中， 实现对应部分代码的类型补全</p><p>声明文件中并不包含实际的代码逻辑， 他做的事情只有一件： <strong>为 typescript 类型检查与推导提供额外的类型信息</strong>。 而使用的语法仍是 typescript 的 declare 关键字， 只不过我们要进一步学习其他打开方式了。</p><p>要详细学习声明文件与declare 关键字， 我们不妨先来看看如何解决上面的问题。 首先是五类线定义的 npm 包， 我们可以通过 declare module 的方式提供其类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">&#39;pkg&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的 pkg 是一个没有类型定义的npm 包（实际并不存在）， 我们来看如何为他添加类型提示.</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;pkg&#39;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>现在我们的 res 就具有了 string 类型！ <code>declare module &#39;pkg&#39;</code> 会默认导入 <code>foo</code> 添加一个具有 handler 的类型， 虽然这里的 <code>pkg</code> 根本不存在。 我们也可以在 <code>declare module</code> 中使用默认导出:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;pkg1&#39;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  <span class="token keyword">export</span> <span class="token keyword">default</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// ----</span>
<span class="token keyword">import</span> bar <span class="token keyword">from</span> <span class="token string">&#39;pkg1&#39;</span><span class="token punctuation">;</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// number</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><blockquote><p>在 <code>pkg</code> 的类型声明中， 你也可以使用 <code>export const handler: () =&gt; string;</code> 效果是一致的， 但由于对 <code>pkg1</code> 我们使用了默认导入， 因此必须要有一个 <code>export default</code></p></blockquote><p>除了为确实类型的模块声明类型以外， 使用类型声明我们还可以为非代码文件， 如图片、css 文件等声明文件。</p><p>对于非代码文件， 比如说 markdown 文件， 假设我们希望导入一个 <code>.md</code> 文件， 由于其本质 和 npm 包 一样是一条导入语句， 因此我们可以类似地使用 declare module 语法：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// declare.d.ts</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;*.md&#39;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> raw<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> raw<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ------</span>
<span class="token keyword">import</span> raw <span class="token keyword">from</span> <span class="token string">&#39;xx.md&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> content <span class="token operator">=</span> raw<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>对于非代码文件， 更常见的其实是 <code>.css</code>、<code>.module.css</code>, <code>.png</code> 这一类， 但基本语法都像相似。</p><p>总结一下， <code>declare module</code> 通常用于为没有提供类型定义的库进行类型补全， 以及为非代码文件提供基本类型定义。 但实际使用中，如果一个库没有内置类型定义， ts 也会提示你， 是否要安装 <code>@types/xxx</code> 这样的包。</p><h2 id="definitelytyped" tabindex="-1"><a class="header-anchor" href="#definitelytyped" aria-hidden="true">#</a> DefinitelyTyped</h2><p>简单来说， <code>@types/</code> 开头的这一类 npm 包均属于 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped" target="_blank" rel="noopener noreferrer">DefinitelyTyped<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>, 它是 ts 维护的， 专门用于为社区存在的<strong>无类型定义的 JavaScript 库</strong>添加类型支持， 常见的又 <code>@types/react</code>, <code>@types/loadsh</code> 等等。</p><p>先来看看 <code>@types/node</code> 中 与 <code>@types/react</code> 中分别是如何进行类型声明的:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @types/node</span>
<span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;fs&#39;</span> <span class="token punctuation">{</span>
 <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token doc-comment comment">/** 省略 */</span><span class="token punctuation">)</span><span class="token operator">:</span> Buffer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// @types/react</span>
<span class="token keyword">declare</span> <span class="token keyword">namespace</span> React <span class="token punctuation">{</span>
 <span class="token keyword">function</span> <span class="token generic-function"><span class="token function">useState</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">,</span> Dispatch<span class="token operator">&lt;</span>SetStateAction<span class="token operator">&lt;</span><span class="token constant">S</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>可以看到 <code>@types/node</code> 中仍然使用 <code>declare module</code> 的方式为 <code>fs</code> 这个内置模块声明了类型， 而 <code>@types/react</code> 则使用的是我们没见过的 <code>declare namespace</code> (后面介绍).</p><p>回到上面的最后一个问题， 如果第三方库并不是通过导出来使用， 而是直接在全局注入了变量， 如 CDN 引入与某些监控买点 sdk 的引入， 我们需要通过 <code>window.xxx</code> 的方式访问， 而类型声明很显然并不存在。 此时我们仍然可以通过类型声明， 但不再是通过 <code>declare module</code> 了·</p><h2 id="扩展已有的类型定义" tabindex="-1"><a class="header-anchor" href="#扩展已有的类型定义" aria-hidden="true">#</a> 扩展已有的类型定义</h2><p>对于全局变量的声明， 还是以window 为例， 实际上 我们如果 Ctrl + 点击代码中的 window， 会发现它已经又类型声明了：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">var</span> window<span class="token operator">:</span> Window <span class="token operator">&amp;</span> <span class="token keyword">typeof</span> globalThis<span class="token punctuation">;</span>

<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
 <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>这行代码来自于 <code>lib.dom.d.ts</code> 文件， 它定义了对浏览器文档对象模型的类型声明， 这就是 ts 提供的内置类型， 也是‘出厂自带’的类型检查能力的依据。 类似的， 还有内置的 <code>lib.es2021.d.ts</code> 这种文件定义了 ECMAScript 每个版本的类型声明新增或改动等等。</p><p>我们要做的， 实际上就是在内置类型声明的基础之上， 在新增一部分属性。 而别忘了， 在 js 中当你访问全局变量时， 是可以直接忽略 <code>window</code> 的</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 不需要 window.onerror = xxx;</span>
<span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>反过来， 在类型声明中， 如果我们直接声明一个变量， 那就相当于将他声明在了全局空间中：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 类型声明</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> <span class="token function-variable function">errorReporter</span><span class="token operator">:</span> <span class="token punctuation">(</span>err<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token comment">// 实际使用</span>
<span class="token function">errorReporter</span><span class="token punctuation">(</span><span class="token string">&#39;err!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>而如果我们就是想将它显示地添加到已有的 <code>Window</code> 接口中呢？ 在接口一节中我们其实已经了解到，如果你有多个同名接口， 那么<strong>这些接口实际上是会被合并的</strong>, 这一特性在类型声明中也是如此。 因此， 我们再声明一个 Window 接口即可.</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">useTracker</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

window<span class="token punctuation">.</span><span class="token function">useTracker</span><span class="token punctuation">(</span><span class="token string">&#39;click!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>类似的， 我们也可以扩展来自 <code>@type/</code> 包的类型定义:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">&#39;fs&#39;</span> <span class="token punctuation">{</span>
 <span class="token keyword">const</span> <span class="token function-variable function">bump</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ----</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bump <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;fs&#39;</span><span class="token punctuation">;</span>

<span class="token function">bump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>总结一下着两个部分， typescript 通过 DefinitelyTyped, 也就是 <code>@types/</code> 系列的 npm 包来为无类型定义的 js npm 包提供类型支持， 这些类型定义的 npm 包内部其实就是数个 <code>.d.ts</code> 这样的声明文件。</p><p>而这些文件主要通过 declare / namespace 的语法进行类型的描述, 我们可以通过项目内额外的声明文件， 来实现为非代码文件的导入， 或者是全局变量添加上类型声明。</p><h2 id="三斜线指令" tabindex="-1"><a class="header-anchor" href="#三斜线指令" aria-hidden="true">#</a> 三斜线指令</h2><p>对于多个类型声明文件， 如果我们想复用某一个已定义的类型， 就可以使用 三斜线指令， 它<strong>就像是声明文件中的导入语句一样</strong>, 他的作用就是<strong>声明当前的文件 依赖的其他类型声明</strong>， 而这里的”其他类型声明“包括了 ts 内置类型说明（<code>lib.d.ts</code>）, 三方库的类型声明以及你自己提供的类型声明文件等。</p><p>三斜线的本质就是一个自闭合的 XML 标签， 其语法大致如下：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">/// &lt;reference path=&quot;./other.d.ts&quot; /&gt;</span>
<span class="token comment">/// &lt;reference types=&quot;node&quot; /&gt;</span>
<span class="token comment">/// &lt;reference lib=&quot;dom&quot; /&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>需要注意的是， 三斜线指令必须被放置在文件的顶部才能生效</strong></p><p>这里的三条指令作用其实都是声明当前文件所依赖的外部类型声明， 只不过使用的方式不同， 分别使用了 path、types、 lib 这三个不同属性。</p><ul><li>使用 path 的 reference 指令， 其 path 的属性的值为一个相对路径， 指向你项目内的其他声明文件。 而编译时候， ts 会沿着 path 指定的路径不断深入寻找， 最深的那个没有其他依赖的声明文件会被最先加载。</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// @types/node 中的示例</span>
<span class="token comment">/// &lt;reference path=&quot;fs.d.ts&quot; /&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>使用 types 的 reference 指令， 其types 的值是一个包名， 也就是你想引入的 <code>@types/</code> 声明， 如上面的例子中我们实际上是在声明当前文件对 <code>@types/node</code> 的依赖。 而如果你的代码文件 (<code>.ts</code>) 中声明了对某一个包的类型导入， 那么在编译产生的声明文件（<code>.d.ts</code>）中会自动包含引用它的指令。</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">/// &lt;reference types=&quot;node&quot; /&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li>使用 lib 的 reference 指令类似于 types， 只不过这里 lib 导入的是 ts 内置类型声明， 如下面的列子我们声明了对 <code>lib.dom.d.ts</code> 的依赖:</li></ul><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// vite/client.d.ts</span>
<span class="token comment">/// &lt;reference  lib=&quot;dom&quot; /&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>而如果我们使用 <code>/// &lt;reference lib=&quot;esnext.promise&quot; /&gt;</code> , 那么依赖的就是 <code>lib.esnext.promise.d.ts</code> 文件。</p><p>这三种指令的目的都是引入当前文件所依赖的其他类型声明， 只不过使用场景不同而已。</p><h2 id="namespace-命名空间" tabindex="-1"><a class="header-anchor" href="#namespace-命名空间" aria-hidden="true">#</a> namespace 命名空间</h2><p>如果说三斜线指令的作用就像导入语句一样， 那么 namespace 就像一个模块文件一样， 将一组强相关的逻辑收拢到一个命名空间内部。</p><p>假设一个场景， 我们的项目里需要接入多个平台的支付 SDK， 最开始只有微信支付和支付宝:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">AliPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>后来又多了美团支付、虚拟货币支付、信用卡支付等等</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">AliPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">CreditCarkPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>随着业务的不断发展， 项目中可能需要引入越来越多的支付 SDK， 甚至还有比特币 、以太坊， 此时将这些所有的支付都放在一个文件内未免过于杂乱了。 这些支付方式其实大致可以分成两种： 现实货币于 虚拟货币。 此时我们就可以使用命名空间来区分这两类 SDK：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 注意， 这里是代码是在 .ts 文件中的， 此时它们具有实际逻辑意义的， 不能和类型混作一谈</span>
<span class="token keyword">export</span> <span class="token keyword">namespace</span> RealCurrency <span class="token punctuation">{</span>
 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AliPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">MeiTuanPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CreditCardPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">namespace</span> VirtualCurrency <span class="token punctuation">{</span>
 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">QQCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">BitCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ETHPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>而命名空间的使用类似于枚举:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> weChatPaySDK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealCurrency</span><span class="token punctuation">.</span><span class="token function">WeChatPaySDK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>唯一需要注意的是， 命名空间内部实际上就像是一个独立的代码文件，因此其中的变量需要到处以后，才能通过 <code>RealCurrency.WeChatPaySDK</code> 这样的形式访问。</p><p><strong>命名空间的内部</strong>还可以再嵌套命名空间， 比如再虚拟货币中再新增区块链货币一类， 此时嵌套的命名空间也需要被导出：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token keyword">namespace</span> RealCurrency <span class="token punctuation">{</span>
 <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">WeChatPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">export</span> <span class="token keyword">namespace</span> BlockChainCurrency <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">BitCoinPaySDK</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">ETHPaySDK</span> <span class="token punctuation">{</span>
    <span class="token function">pay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">&#39;pay success&#39;</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


<span class="token keyword">const</span> ethPaySDK <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealCurrency</span><span class="token punctuation">.</span>BlockChainCurrency<span class="token punctuation">.</span><span class="token function">ETHPaySDK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ethPaySDK<span class="token punctuation">.</span><span class="token function">pay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>类似于类型声明中的同名接口合并， 命名空间也可以进行合并， 但需要通过三斜线指令来声明导入。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// animal.ts</span>
<span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">namespace</span> ProtectedAnimals <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// dog.ts</span>
<span class="token comment">/// &lt;reference path=&quot;animal.ts&quot; /&gt;</span>
<span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">namespace</span> Dog <span class="token punctuation">{</span>
    <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// corgi.ts</span>
<span class="token comment">/// &lt;reference path=&quot;dog.ts&quot; /&gt;</span>
<span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
  <span class="token keyword">export</span> <span class="token keyword">namespace</span> Dog <span class="token punctuation">{</span>
    <span class="token keyword">export</span> <span class="token keyword">namespace</span> Corgi <span class="token punctuation">{</span>
      <span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">corgiBark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>实际使用时需要导入全部的依赖文件：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">/// &lt;reference path=&quot;animal.ts&quot; /&gt;</span>
<span class="token comment">/// &lt;reference path=&quot;dog.ts&quot; /&gt;</span>
<span class="token comment">/// &lt;reference path=&quot;corgi.ts&quot; /&gt;</span>

Animal<span class="token punctuation">.</span>Dog<span class="token punctuation">.</span>Corgi<span class="token punctuation">.</span><span class="token function">corgiBark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>除了在 <code>.ts</code> 文件中使用以外， namespace 也可以在声明文件中使用， 即 <code>declare namespace</code>:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">namespace</span> Animal <span class="token punctuation">{</span>
 <span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">interface</span> <span class="token class-name">Cat</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">declare</span> <span class="token keyword">const</span> dog<span class="token operator">:</span> Animal<span class="token punctuation">.</span>Dog<span class="token punctuation">;</span>
<span class="token keyword">declare</span> <span class="token keyword">const</span> cat<span class="token operator">:</span> Animal<span class="token punctuation">.</span>Cat<span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但如果你在 <code>@types/</code> 系列的包下， 想要通过 namespace 进行模块声明， 还需要将其导出, 然后才会加载到对应的模块下。 以 <code>@types/react</code> 为例:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">export</span> <span class="token operator">=</span> React<span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">as</span> <span class="token keyword">namespace</span> React<span class="token punctuation">;</span>

<span class="token keyword">declare</span> <span class="token keyword">namespace</span> React <span class="token punctuation">{</span>
 <span class="token keyword">const</span> <span class="token function-variable function">sayHi</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>首先我们声明了一个 namespace React， 然后使用 <code>export = React</code> 将它导出了。 这样我们就能在 react 中导入方法时候， 获得 namespace 内部的类型声明， 如 sayHi</p><p>从这一角度来看， <code>declare namespace</code> 其实就类似于普通的 <code>declare</code> 语法， 只是内部的类型我们不在需要使用 declare 关键字（比如我们上面 React 直接内部 <code>const sayHi: () =&gt; &#39;hello&#39;</code>）</p><p>而还有一行 <code>export as namespace React</code>, 他的作用是在启用了 <code>--allowUmdGlobalAccess</code> 配置的情况下， 允许将这个模块作为全局变量使用（也就是不导入直接使用）， 这一特性同样也使用于通过 CDN 资源导入模块时候的变量类型声明</p><p>除了这两处 namespace 使用， React 中还利用 namespace 合并特性， 在全局的命名空间中注入了一些类型：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 本地报错的????</span>
<span class="token keyword">declare</span> global <span class="token punctuation">{</span>
  <span class="token keyword">namespace</span> <span class="token constant">JSX</span> <span class="token punctuation">{</span>
    <span class="token keyword">interface</span> <span class="token class-name">Element</span> <span class="token keyword">extends</span> <span class="token class-name">React</span><span class="token punctuation">.</span>ReactElement<span class="token operator">&lt;</span><span class="token builtin">any</span><span class="token punctuation">,</span> <span class="token builtin">any</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h2><h3 id="通过-jsdoc-在-js-文件中获得类型提示" tabindex="-1"><a class="header-anchor" href="#通过-jsdoc-在-js-文件中获得类型提示" aria-hidden="true">#</a> 通过 JSDoc 在 js 文件中获得类型提示</h3><p>在上面我们提到了可以在 js 中通过 JSDoc 来标注变量类型， 而既然有了类型标注， 那么自然也能享受到 ts 那样的类型提示了。 但这里我们需要使用更强大一些的 JSDoc 能力： <code>@type {}</code> 中使用导入语句</p><p>以拥有海量配置项的 webpack 为例:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;webpack&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Configuration <span class="token punctuation">}</span></span> */</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> config<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个时候你会发现 config 已经可以得到 webpack 的类型提示</p><p>类似的， 也可以直接进行导出:</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token doc-comment comment">/** <span class="token keyword">@type</span> <span class="token class-name"><span class="token punctuation">{</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;webpack&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Configuration <span class="token punctuation">}</span></span> */</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>当然， webpack 本身也支持通过ts文件进行配置， 在使用 ts 配置时候， 一种方式是简单地使用它提供的类型作为一个对象的标注。 而目前更常见的一种方式其实是框架内部提供 <code>defineConfig</code> 这样的方法，让你直接获得类型提示， 如 Vite 中的做法:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineConfig <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vite&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/cqc-hub/vp-blob.io/tree/master/docs/typescript/r.类型声明命名空间.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vp-blob.io/typescript/r.类型声明命名空间.html" class="" aria-label="r.类型声明命名空间"><!--[--><!--]--> r.类型声明命名空间 <!--[--><!--]--></a></span><!----></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vp-blob.io/assets/app.28445bf9.js" defer></script>
  </body>
</html>

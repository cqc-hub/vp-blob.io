<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.43">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/image/favicon.ico"><title></title><meta name="description" content="">
    <link rel="modulepreload" href="/vp-blob.io/assets/app.28445bf9.js"><link rel="modulepreload" href="/vp-blob.io/assets/g.类型工具(part 2).html.037aad7d.js"><link rel="modulepreload" href="/vp-blob.io/assets/g.类型工具(part 2).html.885a698a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.8f018029.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.98776873.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.ec84774a.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.84c58d00.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fb44c11d.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.04557333.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.e4e771ef.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.64a103a2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3013be87.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.f33a1b79.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.f0357039.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.d4018bdd.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.fc637112.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.657af7d7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.af7e2c7e.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.f1da3f4b.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.71e96b0a.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.a8066bef.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.47b96db6.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a39bfc1a.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.2295a28e.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.3fb1f527.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.d26307e6.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.d7704ccc.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.a198ccc8.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.d5d366e2.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.9962dce2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.fe25b76a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.a8456586.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.d6877f1b.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.16fd9c5f.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8ad5ee0.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.e57931a0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.224c5d9e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9483b910.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.21885604.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.afebf168.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.fbc2f79f.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.f5f2a306.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.a8e3ed93.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.4761e1bb.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.645f59cf.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.71743a0c.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.06f977a3.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.ffbf235f.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.03ab869d.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.24317708.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.21818278.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.a0e1348b.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.299f370c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.88fb9194.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.623e016f.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.f71f240c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.70643a0d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.fcb179b9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.a4126bf7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.b9b1e0ca.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.851b045e.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.60e43a8c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.761e4995.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.4c0328e0.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.5f3cb86a.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.8ff82f5e.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.7f1b0f8b.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.b86014e5.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.dba571f1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.c009c8d1.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.06394c55.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.cd077274.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.4933004a.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.93146c89.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.0356a730.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.9f9140e5.js"><link rel="prefetch" href="/vp-blob.io/assets/1 调试 Vue 项目.html.98256e4c.js"><link rel="prefetch" href="/vp-blob.io/assets/2 VsCode Chrome Debugger 断点映射原理.html.b052bd8a.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3e37b7e7.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.6ff36268.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.b6b2b9e2.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c874a8b5.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c3e042f2.js"><link rel="prefetch" href="/vp-blob.io/assets/a.项目环境搭建.html.7a317f56.js"><link rel="prefetch" href="/vp-blob.io/assets/b.基础类型.html.2a865dab.js"><link rel="prefetch" href="/vp-blob.io/assets/c.字面量类型与枚举.html.311f0358.js"><link rel="prefetch" href="/vp-blob.io/assets/d.函数重载与Class.html.cf697cfd.js"><link rel="prefetch" href="/vp-blob.io/assets/e.any、unknown、never.html.6fb392b7.js"><link rel="prefetch" href="/vp-blob.io/assets/f.类型工具(part 1).html.398b4e97.js"><link rel="prefetch" href="/vp-blob.io/assets/h.泛型.html.1bd949ed.js"><link rel="prefetch" href="/vp-blob.io/assets/i.结构化类型系统：类型兼容性判断的幕后.html.52ca17dd.js"><link rel="prefetch" href="/vp-blob.io/assets/j.类型系统层级.html.f34fa417.js"><link rel="prefetch" href="/vp-blob.io/assets/k.条件类型与infer.html.e44fb0eb.js"><link rel="prefetch" href="/vp-blob.io/assets/l.工具类型.html.a09badfd.js"><link rel="prefetch" href="/vp-blob.io/assets/m.反向类型推导.html.62415c6a.js"><link rel="prefetch" href="/vp-blob.io/assets/n.协变与逆变的比较.html.037e5a5d.js"><link rel="prefetch" href="/vp-blob.io/assets/o.进阶.html.013365b5.js"><link rel="prefetch" href="/vp-blob.io/assets/p.模板字符串.html.3b025d3c.js"><link rel="prefetch" href="/vp-blob.io/assets/q.字符串进阶.html.e3e976e6.js"><link rel="prefetch" href="/vp-blob.io/assets/r.类型声明命名空间.html.297e089b.js"><link rel="prefetch" href="/vp-blob.io/assets/s.装饰器.html.861f9241.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.f748203e.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.18ee491b.js"><link rel="prefetch" href="/vp-blob.io/assets/邂逅.html.fcd2c4fb.js"><link rel="prefetch" href="/vp-blob.io/assets/Button.html.9061575a.js"><link rel="prefetch" href="/vp-blob.io/assets/InputNumber.html.a8454023.js"><link rel="prefetch" href="/vp-blob.io/assets/Slider.html.0e8811b9.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.c4c65b97.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.547bbfb0.js"><link rel="prefetch" href="/vp-blob.io/assets/index.html.3a04f0a9.js"><link rel="prefetch" href="/vp-blob.io/assets/1.环境搭建.html.5e39c00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.项目初始化.html.8d1df225.js"><link rel="prefetch" href="/vp-blob.io/assets/1.样式方案的意义.html.0300e3da.js"><link rel="prefetch" href="/vp-blob.io/assets/1.图片加载.html.4367c6e7.js"><link rel="prefetch" href="/vp-blob.io/assets/2.svg组件方式加载.html.52adde68.js"><link rel="prefetch" href="/vp-blob.io/assets/3.JSON加载.html.1119a5b8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.WebWorker脚本.html.8c2848ad.js"><link rel="prefetch" href="/vp-blob.io/assets/5.WebAssembly文件.html.343d643e.js"><link rel="prefetch" href="/vp-blob.io/assets/6.生产环境处理.html.cc2b7662.js"><link rel="prefetch" href="/vp-blob.io/assets/7.单文件or内联.html.8ecb2353.js"><link rel="prefetch" href="/vp-blob.io/assets/8.图片压缩.html.1063515b.js"><link rel="prefetch" href="/vp-blob.io/assets/9.雪碧图优化.html.8722a081.js"><link rel="prefetch" href="/vp-blob.io/assets/1.预构建起因.html.44ede00a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.自定义配置.html.0bffe771.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Esbuild介绍.html.b1a0b6cc.js"><link rel="prefetch" href="/vp-blob.io/assets/2-1.快速上手.html.83703e49.js"><link rel="prefetch" href="/vp-blob.io/assets/2-2.命令行.html.3139a078.js"><link rel="prefetch" href="/vp-blob.io/assets/1.快速上手.html.c6c4dc0a.js"><link rel="prefetch" href="/vp-blob.io/assets/2.常用配置.html.036cd62d.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CSS 预处理器.html.cfc6577d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.CSS Modules.html.f78bbe87.js"><link rel="prefetch" href="/vp-blob.io/assets/3.PostCSS.html.be63d1c8.js"><link rel="prefetch" href="/vp-blob.io/assets/4.CSS In JS.html.93776a99.js"><link rel="prefetch" href="/vp-blob.io/assets/1.初始化.html.b6fed70c.js"><link rel="prefetch" href="/vp-blob.io/assets/1.Build API.html.bbc94483.js"><link rel="prefetch" href="/vp-blob.io/assets/2.serve API.html.a38026e9.js"><link rel="prefetch" href="/vp-blob.io/assets/3.Transform API.html.92ecacce.js"><link rel="prefetch" href="/vp-blob.io/assets/1.基本概念.html.644e2aab.js"><link rel="prefetch" href="/vp-blob.io/assets/1.CDN依赖拉取插件.html.fe27efa4.js"><link rel="prefetch" href="/vp-blob.io/assets/2.实现html构建插件.html.bd744455.js"><link rel="prefetch" href="/vp-blob.io/assets/5-1.Windi CSS.html.b7f872e5.js"><link rel="prefetch" href="/vp-blob.io/assets/5-2.Tailwind CSS.html.53627ba1.js"><link rel="prefetch" href="/vp-blob.io/assets/1.onResolve和onLoad.html.17ca2b9d.js"><link rel="prefetch" href="/vp-blob.io/assets/2.onStart和onEnd.html.0ceab273.js"><link rel="prefetch" href="/vp-blob.io/assets/404.html.a799acdf.js"><link rel="prefetch" href="/vp-blob.io/assets/404.008f7f9a.js"><link rel="prefetch" href="/vp-blob.io/assets/Layout.f041014c.js"><link rel="prefetch" href="/vp-blob.io/assets/Document.7ddbfa27.js"><link rel="prefetch" href="/vp-blob.io/assets/DocumentIntroduction.642e8662.js"><link rel="prefetch" href="/vp-blob.io/assets/FooBar.72140e24.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNav.c0863aa2.js"><link rel="prefetch" href="/vp-blob.io/assets/TypeScriptPrimitiveAndObject.723d323e.js"><link rel="prefetch" href="/vp-blob.io/assets/aMark.e9a27668.js"><link rel="prefetch" href="/vp-blob.io/assets/MyNote.c64d23bd.js"><link rel="prefetch" href="/vp-blob.io/assets/MyHome.27c67e38.js">
    <link rel="stylesheet" href="/vp-blob.io/assets/style.f819ef42.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vp-blob.io/" class=""><img class="logo" src="/vp-blob.io/image/favicon.ico" alt><!----></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vp-blob.io/vite/" class="" aria-label="vite"><!--[--><!--]--> vite <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/typescript/" class="router-link-active" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vp-blob.io/debug/" class="" aria-label="调试"><!--[--><!--]--> 调试 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="笔记"><span class="title">笔记</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="笔记"><span class="title">笔记</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><!--[--><h4 class="navbar-dropdown-subtitle"><span>前端</span></h4><ul class="navbar-dropdown-subitem-wrapper"><!--[--><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/documents/introduction" class="" aria-label="分享"><!--[--><!--]--> 分享 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/wxProgram/" class="" aria-label="微信小程序"><!--[--><!--]--> 微信小程序 <!--[--><!--]--></a></li><li class="navbar-dropdown-subitem"><a href="/vp-blob.io/essay" class="" aria-label="八股文"><!--[--><!--]--> 八股文 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/cqc-hub/vp-blob.io" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/g.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%202).html#类型查询操作符-熟悉又陌生的-typeof" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型查询操作符: 熟悉又陌生的 typeof"><!--[--><!--]--> 类型查询操作符: 熟悉又陌生的 typeof <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/g.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%202).html#类型守卫" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型守卫"><!--[--><!--]--> 类型守卫 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/g.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%202).html#类型断言守卫" class="router-link-active router-link-exact-active sidebar-item" aria-label="类型断言守卫"><!--[--><!--]--> 类型断言守卫 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/g.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%202).html#基于-in-与-instanceof-的类型保护" class="router-link-active router-link-exact-active sidebar-item" aria-label="基于 in 与 instanceof 的类型保护"><!--[--><!--]--> 基于 in 与 instanceof 的类型保护 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/g.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%202).html#扩展" class="router-link-active router-link-exact-active sidebar-item" aria-label="扩展"><!--[--><!--]--> 扩展 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/vp-blob.io/typescript/g.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%202).html#接口的合并" class="router-link-active router-link-exact-active sidebar-item" aria-label="接口的合并"><!--[--><!--]--> 接口的合并 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/vp-blob.io/typescript/g.%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7(part%202).html#更强大的可辨识联合类型分析" class="router-link-active router-link-exact-active sidebar-item" aria-label="更强大的可辨识联合类型分析"><!--[--><!--]--> 更强大的可辨识联合类型分析 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><h2 id="类型查询操作符-熟悉又陌生的-typeof" tabindex="-1"><a class="header-anchor" href="#类型查询操作符-熟悉又陌生的-typeof" aria-hidden="true">#</a> 类型查询操作符: 熟悉又陌生的 typeof</h2><p>typescript 中存在两种功能不同的 <code>typeof</code> 操作符，我们最常见的一种是存在 javascript 中, 用于检查类型的 typeof, 它会返回 <code>string</code> / <code>number</code> / <code>object</code> / <code>undefined</code> 等值。 而除此之外， typescript 还新增了用于类型查询的 typeof, 即 <strong>Type Query Operator</strong>, 这个 typeof 返回的是 typescript 的类型。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;cqc&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> nullVar <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> undefinedVar <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> input<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">;</span>

<span class="token keyword">type</span> <span class="token class-name">Str</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> str<span class="token punctuation">;</span> <span class="token comment">// &#39;cqc&#39;</span>
<span class="token keyword">type</span> <span class="token class-name">Obj</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">;</span> <span class="token comment">// { name: string }</span>

<span class="token keyword">type</span> <span class="token class-name">Null</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> nullVar<span class="token punctuation">;</span> <span class="token comment">// null</span>
<span class="token keyword">type</span> <span class="token class-name">Undefined</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> undefinedVar<span class="token punctuation">;</span> <span class="token comment">// undefined</span>

<span class="token keyword">type</span> <span class="token class-name">Func</span> <span class="token operator">=</span> <span class="token keyword">typeof</span> func<span class="token punctuation">;</span> <span class="token comment">// (input: string) =&gt; boolean</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>你不仅可以直接在类型标注中使用 typeof，还能在工具类型中使用 typeof;</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> input<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

<span class="token keyword">const</span> func2<span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input1<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> input1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">// 入参名字可以变</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>绝大多数情况下， typeof 返回的类型就是你把鼠标悬浮在变量名上的自动推导出的类型， 并且是<strong>最窄的推导程度（即到字面量类型级别）</strong>。</p><p>你也不用担心混用了这两种 typeof， 在逻辑代码中使用的 typeof 一定是 javascript 中的 typeof， 而类型代码(类型标注、类型别名中等) 中的一定是类型查询的 typeof。同时， 为了更好的避免这种情况， 也就是隔离类型层和逻辑层，类型查询 typeof 操作符后面是不允许 使用表达式的：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token function-variable function">inputValid</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> input<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

<span class="token keyword">let</span> isValid<span class="token operator">:</span> <span class="token keyword">typeof</span> <span class="token function">inputValid</span><span class="token punctuation">(</span><span class="token string">&#39;cqc&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不允许</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="类型守卫" tabindex="-1"><a class="header-anchor" href="#类型守卫" aria-hidden="true">#</a> 类型守卫</h2><p>typescript 中提供了非常强大的类型推导能力，它会随着你的代码逻辑而尝试不断的收窄类型， 这一能力称之为<strong>类型控制流分析</strong> (也简单理解为类型推导).</p><p>这么说有的抽象，我们可以想象有一条河流，他从上而下流过你的程序，随着代码的分支分出一条条 支流，在最后重新合并为一个完整的河流. 在河流流动的过程中，如果遇到了有特点条件才会进入支到 (比如 if else 语句, switch case 等), 那这条支流流过这里就会收集对应的信息，等到最后合并时， 它们就会嚷着交流: &quot;我刚刚流过了一个只有字符串类型才能进入的代码分支!&quot; &quot;我刚刚流进了一个只有函数 类型才能进入的代码分支!&quot; ... 就这样，它会把整个程序的类型信息都收集完毕</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>

  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在前面说 never 类型的时候就讲到了， 在类型控制流分析下, 每流过一个 if 分支， 后续联合类型的分支就少了一个, 因为这个类型已经在这个分支处理了， 不会进入下一个分支</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">const</span> strOrNumOrBool<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// string</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// number</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> strOrNumOrBool <span class="token operator">===</span> <span class="token string">&#39;boolean&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// boolean</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> _exitTypeCheck<span class="token operator">:</span> <span class="token builtin">never</span> <span class="token operator">=</span> strOrNumOrBool<span class="token punctuation">;</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;unknown type&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在这里， 我们实际上通过 if 条件中的表达式进行了类型保护， 即告知了流过这里的分析程序 每个 if 分支代码块中是什么类型。 这即是编程语言的类型能力中最重要的一部分： <strong>与实际逻辑紧密关联的类型</strong>。 我们从逻辑中进行 类型的推导, 在返过来让逻辑为类型保驾护航。</p><p>前面说过， 类型控制流分析就像一条河流一样流过，那 if 中的条件表达式要是被提取出来了怎么办？</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> isString <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input <span class="token comment">// string | number （类型并没有被收窄）</span>

    <span class="token comment">// 类型 &#39;string | number&#39; 上不存在属性 charAt</span>
    input<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>奇怪， 我们只是把逻辑提取到了外面而已， 如果 isString 返回了 true， 那 input 也一定是 string 了呀?</p><p>想象类型控制流分析这条河流， 刚流进 <code>if (isString(input))</code> 就戛然而止了. 因为 isString 这个函数在 另外一个地方， 内部的函数判断逻辑并不在 foo 中。 这里的类型控制分析流做不到跨函数上下文来进行类型的信息收集 (但别的类型语言中可能是支持的).</p><p>实际上，将判断逻辑分离出来提取到外部函数中进行复用是非常常见的。为了解决这一类型控制流分析的能力不足， typescript 引入了 <strong>is 关键字</strong> 来显示的提供类型信息。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> isString <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> input <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input <span class="token comment">// string  (input 类型被收窄了)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    input <span class="token comment">// number</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>isString 函数被称为类型守卫，在他的返回值中， 我们不再使用 boolean 作为类型标注，而是使用了 <div class="container" data-v-28f0c476><!--[-->input is string<!--]--></div> ， 这个奇怪的搭配，拆开来看它是这样的:</p><ul><li>input: 函数中的某个参数</li><li><code>is string</code>: 即 <strong>is关键字 + 预期类型</strong>, 如果这个函数返回了 true， 那么 is 关键字前面这个入参的类型， 就会被<strong>调用这个类型守卫的调用方 后续的类型控制分析流收集到</strong>.</li></ul><p>需要注意的是， 类型守卫函数中并不会对判断类型和实际类型的关联做检查:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">const</span> isString <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> input <span class="token keyword">is</span> <span class="token builtin">number</span> <span class="token operator">=&gt;</span> <span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isString</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input <span class="token comment">// 这里被推导成了 number， 类型守卫函数不会检查实际逻辑</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>从这个角度来看， 类型守卫 <strong>有些类似于 类型断言, 但类型守卫更宽松， 也更信任你一些, 你指定什么类型， 它就是什么类型</strong>, 除了简单实用原始类型以外，我们还可以在类型守卫中使用对象类型、联合类型等。比如开发常用的两个守卫:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Falsy</span> <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token operator">|</span> <span class="token string">&#39;&#39;</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> isFalsy <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> val <span class="token keyword">is</span> Falsy <span class="token operator">=&gt;</span> <span class="token operator">!</span>isFalsy<span class="token punctuation">;</span>

<span class="token comment">// 不包括 symbol、 bigint</span>
<span class="token keyword">type</span> <span class="token class-name">Primitive</span> <span class="token operator">=</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">boolean</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> isPrimitive <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token operator">:</span> <span class="token builtin">unknown</span><span class="token punctuation">)</span><span class="token operator">:</span> val <span class="token keyword">is</span> Primitive <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token string">&#39;string&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;boolean&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;undefined&#39;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>除了 typeof 以外， 我们还可以通过许多类似的方式进行类型保护，只要它能在联合类型的类型成员中起到筛选作用.</p><h2 id="类型断言守卫" tabindex="-1"><a class="header-anchor" href="#类型断言守卫" aria-hidden="true">#</a> 类型断言守卫</h2><p>除了使用 is 关键字的类型守卫以外， 其实还存在使用 <code>asserts</code> 关键字的类型断言守卫, 如果你使用过测试用例或者 nodejs 的 assert 模块， 那对断言这个概念应该不陌生:</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">import</span> assert <span class="token keyword">from</span> <span class="token string">&#39;assert&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token string">&#39;cqc&#39;</span><span class="token punctuation">;</span>

<span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> name <span class="token operator">===</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// number 类型</span>
name<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译正常， 运行时候报错</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>上面这段代码在运行时候会抛出错误，因为 assert 接受到的表达式的执行结果是 false。 这其实也类似类型守卫的场景: 如果断言<strong>不成立</strong>， 比如这里意味着值不为 number， 那么断言下方的代码就执行不到（dead code）, 如果断言通过了， 不管最开始是什么类型， 断言过的代码中的类型<strong>一定是符合断言的类型</strong>, 比如在这里就是 number.</p><p>但<strong>断言守卫和类型守卫最不同的在于： 在判断条件不通过时候， 断言守卫需要抛出一个错误</strong>, <strong>类型守卫只需要剔除预期的类型</strong>。 这里抛出的错误可能让你想到了 never 类型，但实际上情况要 复杂一些， 断言守卫并不会始终都抛出错误，所以他的返回值不能简单点使用 never，为此， typescript 3.7 版本专门引入了 asserts 关键字 来进行断言场景下的类型守卫, 比如前面的 assert 方法的签名可以是这样的：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code>  <span class="token comment">// 只能使用标准函数写法， 不然使用时候报错（why？）</span>
  <span class="token comment">// const assert = (condition: any, message: string): asserts condition =&gt; {</span>
  <span class="token comment">//   if (!condition) {</span>
  <span class="token comment">//     throw new Error(message)</span>
  <span class="token comment">//   }</span>
  <span class="token comment">// }</span>

  <span class="token keyword">function</span> <span class="token function">assert</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">,</span> message<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> condition <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>


  <span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    input<span class="token punctuation">;</span> <span class="token comment">// string</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这里使用 <div class="container" data-v-28f0c476><!--[-->asserts condition<!--]--></div> , 而 condition 来自于实际逻辑! 这也意味着， 我们将 <strong>condition 这一逻辑层面的代码， 作为了类型层面的判断依据</strong>. 相当于在返回值类型中使用了 一个逻辑表达式进行了类型标注。</p><p>举例来说， 对于 <code>assert(typeof input === &#39;string&#39;)</code> 这么一个断言, 如果函数成功返回，说明其 后续代码中 condition 均成立，也就是 input 神奇地变为了 string 这一类型。</p><p>这里的condition 甚至可以结合 is 关键字进一步提供类型守卫能力：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token comment">// 用 const assert = xxx 无效, 会报错</span>
<span class="token keyword">function</span> <span class="token function">assert</span><span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">asserts</span> input <span class="token keyword">is</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input <span class="token operator">!==</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;input is not a string!&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>

  input<span class="token punctuation">;</span> <span class="token comment">// string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上面这种情况下， 你无需再为断言守卫传入一个表达式, 而是将这个判断用的表达式放入断言守卫内部， 来获取更独立的代码逻辑。</p><h2 id="基于-in-与-instanceof-的类型保护" tabindex="-1"><a class="header-anchor" href="#基于-in-与-instanceof-的类型保护" aria-hidden="true">#</a> 基于 in 与 instanceof 的类型保护</h2><p><code>in</code> 操作符并不是 typescript 中新增的概念， 而是 javascript 中已有的部分，他可以通过 <code>key in object</code> 的方式来判断 key 是否存在 object 或其原型链上.</p><p>既然可以起到区分作用， 在 typescript 中自然可以通过它来进行类型保护。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  foo<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  fooOnly<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  shared<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  bar<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  barOnly<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  shared<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span> <span class="token keyword">in</span> input<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input<span class="token punctuation">;</span> <span class="token comment">// Foo  (自动推导类型)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    input<span class="token punctuation">;</span> <span class="token comment">// Bar</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>这里 foo / bar, fooOnly / barOnly, shared 属性们都有着不同意义，我们可以使用联合类型的某个类型成员中独有(具有辨识度)的属性来 区分 input 的联合类型。 但是， 如果用不具有辨识度的属性来判断的话， 那么 上面的例子中， if 内被推导的类型仍然是<code>Foo | Bar</code>, else 中则是 <code>never</code>。</p><p>这个可辨识属性可以是结构层面的, 比如结构 A 的 prop 是数组， 结构 B 的 prop 是对象, 或者结构 A 存在 prop 属性， 结构 B 不存在。</p><p>它甚至可以是同属性但字面量不同的差异：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>
  fooOnly<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  diffKey<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
  kind<span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span>
  barOnly<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
  diffKey<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input<span class="token punctuation">.</span>kind <span class="token operator">===</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input<span class="token punctuation">;</span> <span class="token comment">// Foo</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> input<span class="token punctuation">.</span>diffKey <span class="token operator">===</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input<span class="token punctuation">;</span> <span class="token comment">// Foo | Bar (使用 typeof 不起作用 无法区分)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><p>如上面的例子， 对于同名不同值的属性， 需要使用字面量类型才能自动推导正确的属性（不能使用 typeof 区分）</p><p>除此之外， javascript 还存在一个 功能类似于 typeof、in 的操作符： <code>instanceof</code>, 它判断的是原型级别的东西， 如 <code>foo instanceof Base</code> 会 沿着 foo 的原型链来查找 <code>Base.prototype</code> 是否存在其上. 当然，在 es6 无处不在 的今天， 我们可以简单的认为这是判断 foo 是否是 Base 类的实例. 同样的 instanceof 可以进行类型保护：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">class</span> <span class="token class-name">FooBase</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">BarBase</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">FooBase</span> <span class="token punctuation">{</span>
  <span class="token function">fooOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">BarBase</span> <span class="token punctuation">{</span>
  <span class="token function">barOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>input<span class="token operator">:</span> Foo <span class="token operator">|</span> Bar<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>input <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    input<span class="token punctuation">;</span> <span class="token comment">// Foo</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    input<span class="token punctuation">;</span> <span class="token comment">// Bar</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h2 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h2><h3 id="接口的合并" tabindex="-1"><a class="header-anchor" href="#接口的合并" aria-hidden="true">#</a> 接口的合并</h3><p>在将交叉类型的时候， 你可能注意到了, 接口和类型别名都能直接使用交叉类型 <code>&amp;</code>, 但除此之外， 接口还能使用 继承 进行合并，在继承时候 子接口可以声明同名类型， 但不能覆盖父接口中的此属性， <strong>子接口中的类型需要能兼容(extends)父接口中的类型</strong>。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Foo1</span> <span class="token punctuation">{</span>
  info<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  onlyFoo1<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Foo2 中包括了 Foo1 中的所有声明</span>
<span class="token keyword">interface</span> <span class="token class-name">Foo2</span> <span class="token keyword">extends</span> <span class="token class-name">Foo1</span> <span class="token punctuation">{</span>
  <span class="token comment">// 声明同名属性需要兼容父</span>
  info<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 拓展新属性</span>
  onlyFoo2<span class="token operator">:</span> <span class="token builtin">boolean</span><span class="token punctuation">;</span>

  <span class="token comment">// 报错， 不能将 number 分配给 boolean</span>
  onlyFoo1<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// 交叉类型 会合并属性</span>
<span class="token doc-comment comment">/**
 * Foo3 = <span class="token punctuation">{</span>
 *  info: <span class="token punctuation">{</span> age: number; name: string; <span class="token punctuation">}</span>;
 *  onlyFoo1: boolean;
 * <span class="token punctuation">}</span>
 */</span>
<span class="token keyword">type</span> <span class="token class-name">Foo3</span> <span class="token operator">=</span> Foo1 <span class="token operator">&amp;</span> <span class="token punctuation">{</span>
  info<span class="token operator">:</span> <span class="token punctuation">{</span> age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p>这也是接口 和类型别名的重要差异之一 （extends）.</p><p>如果是接口 和 类型别名之间的合并呢？ 其实规则是一样的。</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Base</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">IDerived</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  <span class="token comment">// error  不能 将 number 分配给 string</span>
  name<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">interface</span> <span class="token class-name">IBase</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">type</span> <span class="token class-name">Derived</span> <span class="token operator">=</span> IBase <span class="token operator">&amp;</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Derived:</span>
<span class="token comment">// {</span>
<span class="token comment">//   name: never;</span>
<span class="token comment">//   age: number;</span>
<span class="token comment">// }</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="更强大的可辨识联合类型分析" tabindex="-1"><a class="header-anchor" href="#更强大的可辨识联合类型分析" aria-hidden="true">#</a> 更强大的可辨识联合类型分析</h3><p>类型控制流分析其实是在不停增强的，比如下面的例子在 4.6 以前版本中是报错的：</p><div class="language-typescript ext-ts line-numbers-mode"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Args</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">[</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token builtin">number</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token operator">:</span> Args<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> func<span class="token operator">:</span> <span class="token function-variable function">Func</span> <span class="token operator">=</span> <span class="token punctuation">(</span>kind<span class="token punctuation">,</span> payload<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>kind <span class="token operator">===</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    payload<span class="token punctuation">;</span> <span class="token comment">// 4.6 以前是 string | number, 4.6以后就是 string;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/cqc-hub/vp-blob.io/tree/master/docs/typescript/g.类型工具(part 2).md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!----><!----></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/vp-blob.io/typescript/f.类型工具(part 1).html" class="" aria-label="f.类型工具(part 1)"><!--[--><!--]--> f.类型工具(part 1) <!--[--><!--]--></a></span><span class="next"><a href="/vp-blob.io/typescript/h.泛型.html" class="" aria-label="h.泛型"><!--[--><!--]--> h.泛型 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vp-blob.io/assets/app.28445bf9.js" defer></script>
  </body>
</html>
